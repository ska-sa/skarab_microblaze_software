/**-----------------------------------------------------------------------------
*FILE NAME            : main.c
* ------------------------------------------------------------------------------
*  COMPANY              : PERALEX ELECTRONIC (PTY) LTD
* ------------------------------------------------------------------------------
*  COPYRIGHT NOTICE :
*
*  The copyright, manufacturing and patent rights stemming from this
*  document in any form are vested in PERALEX ELECTRONICS (PTY) LTD.
*
*  (c) Peralex 2011
*
*  PERALEX ELECTRONICS (PTY) LTD has ceded these rights to its clients
*  where contractually agreed.
* ------------------------------------------------------------------------------
*  DESCRIPTION :
*
*  This file contains contains the top level functions for the ROACH3 uBlaze
*  embedded processor.
* ------------------------------------------------------------------------------*/

#include <stdio.h>
#include "xparameters.h"
#include "xil_cache.h"
#include "xintc.h"
#include "xwdttb.h"

#include "register.h"
#include "delay.h"
#include "eth_mac.h"
#include "flash_sdram_controller.h"
#include "icape_controller.h"
#include "isp_spi_controller.h"
#include "one_wire.h"
#include "i2c_master.h"
#include "constant_defs.h"
#include "eth_sorter.h"
#include "sensors.h"
#include "improved_read_write.h"
#include "invalid_nack.h"
#include "dhcp.h"
#include "lldp.h"

#define DHCP_BOUND_COUNTER_VALUE  600

/* local function prototypes */
static int vSendDHCPMsg(struct sDHCPObject *pDHCPObjectPtr, void *pUserData);
static int vSetInterfaceConfig(struct sDHCPObject *pDHCPObjectPtr, void *pUserData);

/* temp global definition */
static volatile u8 uFlagRunTask_DHCP = 0;
static volatile u8 uFlagRunTask_LLDP = 1; /* Set LLDP flag to 1 to send LLDP packet at start up */
static volatile u8 uFlagRunTask_CheckDHCPBound = 0;
static struct sDHCPObject DHCPContextState[NUM_ETHERNET_INTERFACES];  /* TODO can we narrow down the scope of this data? */

//=================================================================================
//	TimerHandler
//--------------------------------------------------------------------------------
//	This method handles the interrupts generated by the Timer.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	CallBackRef			IN	Reference to timer object
//	uTimerCounterNumber	IN	There are two timers inside the timer object
//
//	Return
//	------
//	None
//=================================================================================
void TimerHandler(void * CallBackRef, u8 uTimerCounterNumber)
{
	u8 uIndex;
	u8 u40GbE1_Dhcp_En = 0;
	u8 u40GbE2_Dhcp_En = 0;
	u8 u40GbE3_Dhcp_En = 0;
	u8 u40GbE4_Dhcp_En = 0;
	u8 u40GbE1_Link_Up = 0;
	u8 u40GbE2_Link_Up = 0;
	u8 u40GbE3_Link_Up = 0;
	u8 u40GbE4_Link_Up = 0;

	// Every 100 ms, send another ARP request
	uUpdateArpRequests = ARP_REQUEST_UPDATE;


  /* set the dhcp task flag every 100ms which in turn runs dhcp state machine */
  //uFlagRunTask_LLDP = 1;

	// LLDP every 10 seconds (timer every 100 ms)
	if(uLLDPTimerCounter == 0x258)
	{
		uLLDPTimerCounter = 0x0;
		uFlagRunTask_LLDP = 1;

	}
	else{
		uLLDPTimerCounter++;
	}


  /* set the dhcp task flag every 100ms which in turn runs dhcp state machine */
  uFlagRunTask_DHCP = 1;

  uFlagRunTask_CheckDHCPBound = 1;

	// DHCP every 10 seconds (timer every 100 ms)
	if (uDHCPTimerCounter == 0x64)
	{
		uDHCPTimerCounter = 0x0;

		for (uIndex = 0; uIndex < NUM_ETHERNET_INTERFACES; uIndex++)
		{
      /* TODO verify if we can remove these */
			//uDHCPRetryTimer[uIndex] = DHCP_RETRY_ENABLED;
			//uEthernetNeedsReset[uIndex] = NEEDS_RESET;

			// Send out ARP requests every 60 seconds
			if (uIGMPTimerCounter == 0x5)
			{
				uIGMPSendMessage[uIndex] = IGMP_SEND_MESSAGE;
				uCurrentIGMPMessage[uIndex] = 0x0;
			}
		}

		// Only send IGMP message reports every 60 seconds
		if (uIGMPTimerCounter == 0x5)
			uIGMPTimerCounter = 0;
		else
			uIGMPTimerCounter++;

	}
	else
		uDHCPTimerCounter++;

	uQSFPUpdateStatusEnable = UPDATE_QSFP_STATUS;

	if (uQSFPStateCounter == 0x1)
	{
		if (uQSFPState == QSFP_STATE_RESET)
		{
			uQSFPStateCounter++;
			uQSFPState = QSFP_STATE_BOOTLOADER_VERSION_WRITE_MODE;
		}
	}
	// Allow 3 seconds for QSFP+ to be ready
	else if (uQSFPStateCounter == 0x1E)
	{
		if (uQSFPState == QSFP_STATE_STARTING_APPLICATION_MODE)
		{
			uQSFPState = QSFP_STATE_APPLICATION_MODE;
		}
	}
	else
		uQSFPStateCounter++;

  /* TODO: move the following code to main() rather */
  /* use macros for now to get rid of potential bugs and compiler warnings since
     the following code indexes the array above the array bounds if all possible
     40gbe i/f are not enabled */

#if NUM_ETHERNET_INTERFACES > 1
    //if 40GbE link 1 is up enable link else disable link
	if(uEthernetLinkUp[1] == LINK_UP)
	{
		u40GbE1_Link_Up = 0x01;
		//if 40GbE DHCP is complete then set true else false
		if (uDHCPState[1] == DHCP_STATE_COMPLETE)
		{
			u40GbE1_Dhcp_En = 0x01;
		}
		else
		{
			u40GbE1_Dhcp_En = 0x00;
		}
	}
	else
	{
		u40GbE1_Link_Up = 0x00;
		u40GbE1_Dhcp_En = 0x00;
	}
#endif

#if NUM_ETHERNET_INTERFACES > 2
    //if 40GbE link 2 is up enable link else disable link
	if(uEthernetLinkUp[2] == LINK_UP)
	{
		u40GbE2_Link_Up = 0x01;
		//if 40GbE DHCP is complete then set true else false
		if (uDHCPState[2] == DHCP_STATE_COMPLETE)
		{
			u40GbE2_Dhcp_En = 0x01;
		}
		else
		{
			u40GbE2_Dhcp_En = 0x00;
		}
	}
	else
	{
		u40GbE2_Link_Up = 0x00;
		u40GbE2_Dhcp_En = 0x00;
	}
#endif

#if NUM_ETHERNET_INTERFACES > 3
    //if 40GbE link 3 is up enable link else disable link
	if(uEthernetLinkUp[3] == LINK_UP)
	{
		u40GbE3_Link_Up = 0x01;
		//if 40GbE DHCP is complete then set true else false
		if (uDHCPState[3] == DHCP_STATE_COMPLETE)
		{
			u40GbE3_Dhcp_En = 0x01;
		}
		else
		{
			u40GbE3_Dhcp_En = 0x00;
		}
	}
	else
	{
		u40GbE3_Link_Up = 0x00;
		u40GbE3_Dhcp_En = 0x00;
	}
#endif

#if NUM_ETHERNET_INTERFACES > 4
    //if 40GbE link 4 is up enable link else disable link
	if(uEthernetLinkUp[4] == LINK_UP)
	{
		u40GbE4_Link_Up = 0x01;
		//if 40GbE DHCP is complete then set true else false
		if (uDHCPState[4] == DHCP_STATE_COMPLETE)
		{
			u40GbE4_Dhcp_En = 0x01;
		}
		else
		{
			u40GbE4_Dhcp_En = 0x00;
		}
	}
	else
	{
		u40GbE4_Link_Up = 0x00;
		u40GbE4_Dhcp_En = 0x00;
	}
#endif

	uFrontPanelLedsValue = u40GbE4_Link_Up <<7 | u40GbE4_Dhcp_En <<6 | u40GbE3_Link_Up <<5 | u40GbE3_Dhcp_En <<4 | u40GbE2_Link_Up<<3 | u40GbE2_Dhcp_En<<2 | u40GbE1_Link_Up<<1 | u40GbE1_Dhcp_En;
	WriteBoardRegister(C_WR_FRONT_PANEL_STAT_LED_ADDR, uFrontPanelLedsValue);

/*  // Flash front panel LEDS until 1GBE has completed DHCP
	if (uDHCPState[0] != DHCP_STATE_COMPLETE)
	{
		uDHCPCompleteSetLeds = FALSE;
		if (uFrontPanelTimerCounter == 0xA)
		{
			if (uFrontPanelLeds == LED_OFF)
			{
				uFrontPanelLeds = LED_ON;
				WriteBoardRegister(C_WR_FRONT_PANEL_STAT_LED_ADDR, 0xFF);
			}
			else
			{
				uFrontPanelLeds = LED_OFF;
				WriteBoardRegister(C_WR_FRONT_PANEL_STAT_LED_ADDR, 0x00);
			}

			uFrontPanelTimerCounter = 0x0;
		}
		else
			uFrontPanelTimerCounter++;
	}
	else
	{
		if (uDHCPCompleteSetLeds == FALSE)
		{
			uDHCPCompleteSetLeds = TRUE;
			uFrontPanelLeds = LED_ON;
			WriteBoardRegister(C_WR_FRONT_PANEL_STAT_LED_ADDR, 0xFF);
		}
	}
*/

}



//=================================================================================
//	EthernetRecvHandler
//--------------------------------------------------------------------------------
//	This method processes a packet stored in uReceiveBuffer.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	uId			IN		ID of network interface that packet was received from
//	uNumWords	IN		Packet size in 32 bit words
//	uResponsePacketLength	OUT	Length of response packet in bytes
//
//	Return
//	------
//	XST_SUCCESS if successful
//=================================================================================
int EthernetRecvHandler(u8 uId, u32 uNumWords, u32 * uResponsePacketLengthBytes)
{
	// L2 - Ethernet
	// L3 - IP(v4) / ARP
	// L4 - UDP
	// L5 - command protocol
	u32 uL2PktLen;
	u32 uL3PktLen;
	u32 uL4PktLen;
	u32 uL5PktLen;
	u8 *pL2Ptr;
	u8 *pL3Ptr;
	u8 *pL4Ptr;
	u8 *pL5Ptr;
	u8 *uResponsePacketPtr;
	u32 uResponseLength;

	uResponsePacketPtr = (u8*) (uTransmitBuffer);
	uResponsePacketPtr = uResponsePacketPtr + sizeof(sEthernetHeaderT) + sizeof(sIPV4HeaderT) + sizeof(sUDPHeaderT);

	struct sEthernetHeader *EthHdr;
	u32 uL3Proto;
	u32 uL3TOS;
	u32 uUdpSrcPort;
	u32 uUdpDstPort;
	int iStatus;

	// Check we have enough data to proceed: i.e. at least valid Ethernet header
	uL2PktLen = uNumWords * 4;

	if (uL2PktLen < sizeof(struct sEthernetHeader))
		return XST_FAILURE;

	pL2Ptr = (u8 *) (uReceiveBuffer);
	EthHdr = (struct sEthernetHeader *) pL2Ptr;

	// Cache MAC source address for response
	uResponseMacHigh = EthHdr->uSourceMacHigh;
	uResponseMacMid = EthHdr->uSourceMacMid;
	uResponseMacLow = EthHdr->uSourceMacLow;

	pL3Ptr = pL2Ptr + sizeof(struct sEthernetHeader);
	uL3PktLen = uL2PktLen - sizeof(struct sEthernetHeader);

	// TO DO: HANDLE ALL NON-IP/UDP PACKETS HERE
	if (EthHdr->uEthernetType == ETHERNET_TYPE_ARP)
	{

		iStatus = CheckArpRequest(uId, uEthernetFabricIPAddress[uId], uL3PktLen, pL3Ptr);
		if (iStatus == XST_SUCCESS)
		{
#ifdef DEBUG_PRINT
			//xil_printf("ARP packet received!\r\n");
#endif
			ArpHandler(uId, ARP_RESPONSE, pL3Ptr, (u8 *) uTransmitBuffer, uResponsePacketLengthBytes, 0x0);

			return XST_SUCCESS;
		}
		else
			return XST_FAILURE;

	}
	else if (EthHdr->uEthernetType == ETHERNET_TYPE_IPV4)
	{

		//xil_printf("IP packet received!\r\n");
		iStatus = CheckIPV4Header(uEthernetFabricIPAddress[uId], uEthernetFabricSubnetMask[uId], uL3PktLen, pL3Ptr);

		if (iStatus == XST_SUCCESS)
		{

			pL4Ptr = ExtractIPV4FieldsAndGetPayloadPointer(pL3Ptr, &uL4PktLen, (u32 *) &uResponseIPAddr, &uL3Proto, &uL3TOS);

			if ((uL3Proto == IP_PROTOCOL_ICMP)&&(uL3TOS == IP_PING_TOS))
			{
				iStatus = CheckICMPHeader(uL4PktLen, pL4Ptr);

				if (iStatus == XST_SUCCESS)
				{
#ifdef DEBUG_PRINT
					//xil_printf("ICMP packet received!\r\n");
#endif
					ICMPHandler(uId, pL4Ptr, uL4PktLen, (u8 *) uTransmitBuffer, uResponsePacketLengthBytes);
					return XST_SUCCESS;

				}
				else
					return XST_FAILURE;
			}
			else if (uL3Proto == IP_PROTOCOL_UDP)
			{

				//xil_printf("UDP packet received!\r\n");

				iStatus = CheckUdpHeader(pL3Ptr, uL4PktLen, pL4Ptr);
				if (iStatus == XST_SUCCESS)
				{
					pL5Ptr = ExtractUdpFieldsAndGetPayloadPointer(pL4Ptr,& uL5PktLen, & uUdpSrcPort, & uUdpDstPort);

					uResponseUDPPort = uUdpSrcPort;

					// Command protocol
					if (uUdpDstPort == ETHERNET_CONTROL_PORT_ADDRESS)
					{
						iStatus = CommandSorter(uId, pL5Ptr, uL5PktLen, uResponsePacketPtr, & uResponseLength);

						if (iStatus == XST_SUCCESS)
						{
							// Create rest of Ethernet packet in transmit buffer for response
							CreateResponsePacket(uId, (u8 *) uTransmitBuffer, uResponseLength);
							* uResponsePacketLengthBytes = (uResponseLength + sizeof(sEthernetHeaderT) + sizeof(sIPV4HeaderT) + sizeof(sUDPHeaderT));

							return XST_SUCCESS;
						}
						else
							return XST_FAILURE;

					}
/**** DHCP NOW handled by new DHCP code ****/
#if 0
					else if (uUdpDstPort == DHCP_CLIENT_UDP_PORT)
					{
						iStatus = CheckDHCPHeader(uId, uL5PktLen, pL5Ptr);

						if (iStatus == XST_SUCCESS)
						{
#ifdef DEBUG_PRINT
							xil_printf("DHCP [%02x] packet received!\r\n", uId);
#endif
							// iStatus = DHCPHandler(uId, pL5Ptr, uL5PktLen, (u8 *) uTransmitBuffer, uResponsePacketLengthBytes);

							return iStatus;
						}
						else
							return XST_FAILURE;
					}
#endif
					else
						return XST_FAILURE;

				}
				else
        {
          xil_printf("check UDP header failed: src mac %04x.%04x.%04x\r\n", EthHdr->uSourceMacHigh, EthHdr->uSourceMacMid, EthHdr->uSourceMacLow);
					return XST_FAILURE;
        }
			}
			else
				return XST_FAILURE;
		}
		else
			return XST_FAILURE;
	}
	else
		return XST_FAILURE;

}

//=================================================================================
//	ArpRequestHandler
//--------------------------------------------------------------------------------
//	This method constucts ARP requests to populate the ARP caches in the fabric
//	Ethernet interfaces.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void ArpRequestHandler()
{
	u32 uCurrentArpRequestIPAddress;
	u32 uResponseLength;

	uUpdateArpRequests = ARP_REQUEST_DONT_UPDATE;

	if (uEnableArpRequests[uCurrentArpEthernetInterface] == ARP_REQUESTS_ENABLE)
	{
	   	// Create an ARP request
	    uCurrentArpRequestIPAddress = uEthernetSubnet[uCurrentArpEthernetInterface] | uCurrentArpRequest;
	    ArpHandler(uCurrentArpEthernetInterface, ARP_REQUEST, (u8*) uReceiveBuffer, (u8*) uTransmitBuffer, & uResponseLength, uCurrentArpRequestIPAddress);
	   	uResponseLength = (uResponseLength >> 2);
	    TransmitHostPacket(uCurrentArpEthernetInterface, & uTransmitBuffer[0], uResponseLength);
	}

    if (uCurrentArpRequest == 254)
    {
		uCurrentArpRequest = 1;

		if ((uCurrentArpEthernetInterface + 1) == NUM_ETHERNET_INTERFACES)
    		uCurrentArpEthernetInterface = 0;
    	else
    		uCurrentArpEthernetInterface++;
    }
    else
    	uCurrentArpRequest++;
}

//=================================================================================
//	UpdateEthernetLinkUpStatus
//--------------------------------------------------------------------------------
//	This method updates the Ethernet link up status. The Ethernet interface is not
//	checked for received messages if it is not up. When the Ethernet link comes up,
//	the ARP packet requests are enabled to populate the ARP cache.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	uId			IN		ID of selected Ethernet interface
//
//	Return
//	------
//	None
//=================================================================================
void UpdateEthernetLinkUpStatus(u8 uId){
  u32 uReg, uMask;

  uReg = ReadBoardRegister(C_RD_ETH_IF_LINK_UP_ADDR);
  uMask = 1 << uId;

  if ((uReg & uMask) != LINK_DOWN){
    // Check if the link was previously down
    if (uEthernetLinkUp[uId] == LINK_DOWN){
      xil_printf("LINK %x HAS COME UP!\r\n",uId);
 
      if (uId == 0){  /* 1gbe i/f */
        /* do not enable dhcp in loopback mode */
#ifndef DO_1GBE_LOOPBACK_TEST
        vDHCPStateMachineReset(&DHCPContextState[uId]);
        uDHCPSetStateMachineEnable(&DHCPContextState[uId], SM_TRUE);
#endif
      } else {    /* for all other i/f's i.e. the 40gbe i/f's */
        /* do not enable dhcp in loopback mode */
#ifndef DO_40GBE_LOOPBACK_TEST
        vDHCPStateMachineReset(&DHCPContextState[uId]);
        uDHCPSetStateMachineEnable(&DHCPContextState[uId], SM_TRUE);
#endif
      }
    }

    uEthernetLinkUp[uId] = LINK_UP;
  } else {
    // Check if the link was previously up
    if (uEthernetLinkUp[uId] == LINK_UP){
      xil_printf("LINK %x HAS GONE DOWN!\r\n", uId);

      if (uId == 0){  /* 1gbe i/f */
        /* do not set in loopback mode */
#ifndef DO_1GBE_LOOPBACK_TEST
        vDHCPStateMachineReset(&DHCPContextState[uId]); /* this will reset and disable dhcp state machine */
        uEthernetFabricIPAddress[uId] = 0;
        uEthernetGatewayIPAddress[uId] = 0;
        uEthernetSubnet[uId] = 0;
#endif
      } else {
        /* do not set in loopback mode */
#ifndef DO_40GBE_LOOPBACK_TEST
        vDHCPStateMachineReset(&DHCPContextState[uId]); /* this will reset and disable dhcp state machine */
        uEthernetFabricIPAddress[uId] = 0;
        uEthernetGatewayIPAddress[uId] = 0;
        uEthernetSubnet[uId] = 0;
#endif
      }
    }

    uEthernetLinkUp[uId] = LINK_DOWN;
    uEnableArpRequests[uId] = ARP_REQUESTS_DISABLE;

    uIGMPState[uId] = IGMP_STATE_NOT_JOINED;
  }
}

//=================================================================================
//	UpdateQSFPStatus
//--------------------------------------------------------------------------------
//	This method updates the status of modules present and LEDs.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void UpdateQSFPStatus()
{
	u16 uWriteBytes[7];
	u16 uReadBytes[3];
	int iStatus = XST_SUCCESS;
	u32 uReg;
	u8 uId = 0x0;
	u32 uLedTxReg = 0x0;
	u32 uLedRxReg = 0x0;
	u32 uLinkMask = 0x10000;
	u32 uActivityMask = 0x20000;

	if ((uPxSerialNumber == 93121)&&(uQSFPMezzanineLocation == 1))
	{
		// ONE OF THE PROTOTYPE SYSTEMS HAS A PROBLEM WITH I2C ON MEZZANINE SITE 1
		// BRING ALL CHANNELS OUT OF RESET
		// DON'T TRY TO ACCESS I2C
		uQSFPCtrlReg = 0x0;
		WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
	}
	else
	{
		if (uQSFPUpdateStatusEnable == UPDATE_QSFP_STATUS)
		{
			uQSFPUpdateStatusEnable = DO_NOT_UPDATE_QSFP_STATUS;

			if (uQSFPState == QSFP_STATE_BOOTLOADER_VERSION_WRITE_MODE)
			{
				// Need to read and store QSFP+ bootloader version before exit bootloader mode
				uWriteBytes[0] = QSFP_BOOTLOADER_READ_OPCODE;
				uWriteBytes[1] = ((QSFP_BOOTLOADER_VERSION_ADDRESS >> 24) & 0xFF);
				uWriteBytes[2] = ((QSFP_BOOTLOADER_VERSION_ADDRESS >> 16) & 0xFF);
				uWriteBytes[3] = ((QSFP_BOOTLOADER_VERSION_ADDRESS >> 8) & 0xFF);
				uWriteBytes[4] = (QSFP_BOOTLOADER_VERSION_ADDRESS & 0xFF);
				uWriteBytes[5] = 0x01; // Reading 1 byte
				//xil_printf("QSFP+ Mezzanine writing version address.\r\n");

				iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_BOOTLOADER_SLAVE_ADDRESS, uWriteBytes, 6);

				if (iStatus != XST_SUCCESS)
					xil_printf("BOOTLOADER I2C WRITE FAILED\r\n");

				uQSFPState = QSFP_STATE_BOOTLOADER_VERSION_READ_MODE;
			}
			else if (uQSFPState == QSFP_STATE_BOOTLOADER_VERSION_READ_MODE)
			{
				//xil_printf("QSFP+ Mezzanine reading bootloader version.\r\n");

				iStatus = ReadI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_BOOTLOADER_SLAVE_ADDRESS, uReadBytes, 1);

				if (iStatus != XST_SUCCESS)
					xil_printf("BOOTLOADER I2C READ FAILED\r\n");

				uQSFPBootloaderVersionMajor = (uReadBytes[0] >> 4) & 0xF;
				uQSFPBootloaderVersionMinor = uReadBytes[0] & 0xF;

				xil_printf("QSFP+ Mezzanine bootloader version: %x.%x\r\n", uQSFPBootloaderVersionMajor, uQSFPBootloaderVersionMinor);

				uQSFPState = QSFP_STATE_INITIAL_BOOTLOADER_MODE;
			}
			else if(uQSFPState == QSFP_STATE_INITIAL_BOOTLOADER_MODE)
			{
				uWriteBytes[0] = QSFP_LEAVE_BOOTLOADER_MODE;
				xil_printf("QSFP+ Mezzanine leaving bootloader mode.\r\n");

				iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_BOOTLOADER_SLAVE_ADDRESS, uWriteBytes, 1);

				if (iStatus != XST_SUCCESS)
					xil_printf("BOOTLOADER I2C WRITE FAILED\r\n");

				uQSFPState = QSFP_STATE_STARTING_APPLICATION_MODE;
				//uQSFPStateCounter = 0;
			}
			else if (uQSFPState == QSFP_STATE_APPLICATION_MODE)
			{
				if (uQSFPI2CMicroblazeAccess == QSFP_I2C_MICROBLAZE_ENABLE)
				{
					if (uQSFPUpdateState == QSFP_UPDATING_TX_LEDS)
					{
						uQSFPUpdateState = QSFP_UPDATING_RX_LEDS;

						uReg = ReadBoardRegister(C_RD_ETH_IF_LINK_UP_ADDR);
						//xil_printf("uReg: %x\r\n", uReg);

#ifdef SKARAB_BSP
						for (uId = 0x0; uId < 0x4; uId++)
#else
						for (uId = 0x0; uId < (NUM_ETHERNET_INTERFACES - 1); uId++)
#endif
						{
							// Check TX link
							if ((uReg & uLinkMask) != 0x0)
							{
								// Check if activity as well
								if ((uReg & uActivityMask) != 0x0)
									uLedTxReg = uLedTxReg | (LED_FLASHING << (uId * 2));
								else
									uLedTxReg = uLedTxReg | (LED_ON << (uId * 2));
							}
							else
								uLedTxReg = uLedTxReg | (LED_OFF << (uId * 2));

							uLinkMask = uLinkMask << 2;
							uActivityMask = uActivityMask << 2;

							// Check RX link
							if ((uReg & uLinkMask) != 0x0)
							{
								// Check if activity as well
								if ((uReg & uActivityMask) != 0x0)
									uLedRxReg = uLedRxReg | (LED_FLASHING << (uId * 2));
								else
									uLedRxReg = uLedRxReg | (LED_ON << (uId * 2));
							}
							else
								uLedRxReg = uLedRxReg | (LED_OFF << (uId * 2));

							uLinkMask = uLinkMask << 2;
							uActivityMask = uActivityMask << 2;
						}

						// GT 04/06/2015 CHANGE TO ALWAYS WRITE if (uLedTxReg != uQSFPMezzanineCurrentTxLed)
						//{
							uWriteBytes[0] = QSFP_LED_TX_REG_ADDRESS;
							uWriteBytes[1] = uLedTxReg;
							iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uWriteBytes, 2);

							if (iStatus != XST_SUCCESS)
								xil_printf("TX LED MEZ I2C WRITE FAILED\r\n");

							//xil_printf("uLedTxReg: %x\r\n", uLedTxReg);
							uQSFPMezzanineCurrentTxLed = uLedTxReg;
						//}
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_RX_LEDS)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_0_WRITE;

						uReg = ReadBoardRegister(C_RD_ETH_IF_LINK_UP_ADDR);

#ifdef SKARAB_BSP
						for (uId = 0x0; uId < 0x4; uId++)
#else
						for (uId = 0x0; uId < (NUM_ETHERNET_INTERFACES - 1); uId++)
#endif
						{
							// Check TX link
							if ((uReg & uLinkMask) != 0x0)
							{
								// Check if activity as well
								if ((uReg & uActivityMask) != 0x0)
									uLedTxReg = uLedTxReg | (LED_FLASHING << (uId * 2));
								else
									uLedTxReg = uLedTxReg | (LED_ON << (uId * 2));
							}
							else
								uLedTxReg = uLedTxReg | (LED_OFF << (uId * 2));

							uLinkMask = uLinkMask << 2;
							uActivityMask = uActivityMask << 2;

							// Check RX link
							if ((uReg & uLinkMask) != 0x0)
							{
								// Check if activity as well
								if ((uReg & uActivityMask) != 0x0)
									uLedRxReg = uLedRxReg | (LED_FLASHING << (uId * 2));
								else
									uLedRxReg = uLedRxReg | (LED_ON << (uId * 2));
							}
							else
								uLedRxReg = uLedRxReg | (LED_OFF << (uId * 2));

							uLinkMask = uLinkMask << 2;
							uActivityMask = uActivityMask << 2;
						}

						// GT 04/06/2015 CHANGE TO ALWAYS WRITE if (uLedRxReg != uQSFPMezzanineCurrentRxLed)
						//{
							uWriteBytes[0] = QSFP_LED_RX_REG_ADDRESS;
							uWriteBytes[1] = uLedRxReg;
							iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uWriteBytes, 2);

							if (iStatus != XST_SUCCESS)
								xil_printf("RX LED MEZ I2C WRITE FAILED\r\n");

							//xil_printf("uLedRxReg: %x\r\n", uLedRxReg);
							uQSFPMezzanineCurrentRxLed = uLedRxReg;
						//}
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_0_WRITE)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_0_READ;

						uWriteBytes[0] = QSFP_MODULE_0_PRESENT_REG_ADDRESS;
						iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uWriteBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 0 MEZ I2C WRITE FAILED\r\n");
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_0_READ)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_1_WRITE;

						iStatus = ReadI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uReadBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 0 MEZ I2C READ FAILED\r\n");

						if (uReadBytes[0] != 0x0)
							// If a module is present, take out of reset
							uQSFPCtrlReg = uQSFPCtrlReg & (~ QSFP0_RESET);
						else
							// If a module is not present, put in reset
							uQSFPCtrlReg = uQSFPCtrlReg | QSFP0_RESET;

						WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_1_WRITE)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_1_READ;

						uWriteBytes[0] = QSFP_MODULE_1_PRESENT_REG_ADDRESS;
						iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uWriteBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 1 MEZ I2C WRITE FAILED\r\n");
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_1_READ)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_2_WRITE;

						iStatus = ReadI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uReadBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 1 MEZ I2C READ FAILED\r\n");

						if (uReadBytes[0] != 0x0)
							// If a module is present, take out of reset
							uQSFPCtrlReg = uQSFPCtrlReg & (~ QSFP1_RESET);
						else
							// If a module is not present, put in reset
							uQSFPCtrlReg = uQSFPCtrlReg | QSFP1_RESET;

						WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_2_WRITE)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_2_READ;

						uWriteBytes[0] = QSFP_MODULE_2_PRESENT_REG_ADDRESS;
						iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uWriteBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 2 MEZ I2C WRITE FAILED\r\n");
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_2_READ)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_3_WRITE;

						iStatus = ReadI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uReadBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 2 MEZ I2C READ FAILED\r\n");

						if (uReadBytes[0] != 0x0)
							// If a module is present, take out of reset
							uQSFPCtrlReg = uQSFPCtrlReg & (~ QSFP2_RESET);
						else
							// If a module is not present, put in reset
							uQSFPCtrlReg = uQSFPCtrlReg | QSFP2_RESET;

						WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_3_WRITE)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_3_READ;

						uWriteBytes[0] = QSFP_MODULE_3_PRESENT_REG_ADDRESS;
						iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uWriteBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 3 MEZ I2C WRITE FAILED\r\n");
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_3_READ)
					{
						uQSFPUpdateState = QSFP_UPDATING_TX_LEDS;

						iStatus = ReadI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uReadBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 3 MEZ I2C READ FAILED\r\n");

						if (uReadBytes[0] != 0x0)
							// If a module is present, take out of reset
							uQSFPCtrlReg = uQSFPCtrlReg & (~ QSFP3_RESET);
						else
							// If a module is not present, put in reset
							uQSFPCtrlReg = uQSFPCtrlReg | QSFP3_RESET;

						WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
					}
				}
			}
		}
	}
}

//=================================================================================
//	InitialiseEthernetInterfaceParameters
//--------------------------------------------------------------------------------
//	This method configures the Ethernet interfaces with some default values.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void InitialiseEthernetInterfaceParameters()
{
	u8 uId;
	u16 uRom[8];
	u16 uSerial[4];
	u16 uFabricMacHigh;
	u16 uFabricMacMid;
	u16 uFabricMacLow;
	u16 uPxSerial[3];
	int iSuccess;
	u16 uRomCRC;

	uCurrentArpEthernetInterface = 0;
	uCurrentArpRequest = 1;
	uUpdateArpRequests = ARP_REQUEST_DONT_UPDATE;
	uDHCPCompleteSetLeds = FALSE;
	uPreviousAsyncSdramRead = 0;
	uPreviousSequenceNumber = 0;

	iSuccess = OneWireReadRom(uRom, MB_ONE_WIRE_PORT);

	if (iSuccess == XST_SUCCESS)
	{
		// GT 05/06/2015 CHECK CRC OF ROM TO CONFIRM OK
		uRomCRC = OneWireCrc8(& uRom[0], 0x7);
		if (uRomCRC != uRom[7])
		{
			xil_printf("MB 1-wire CRC incorrect.\r\n");
			uSerial[0] = 0xFF;
			uSerial[1] = 0xFF;
			uSerial[2] = 0xFF;
			uSerial[3] = 0xFF;
		}
		else
		{
			// Read the serial number
			iSuccess = DS2433ReadMem(uRom, 0, uSerial, 4, 0, 0, MB_ONE_WIRE_PORT);

			if (iSuccess == XST_FAILURE)
			{
				xil_printf("Failed to read serial number.\r\n");
				uSerial[0] = 0xFF;
				uSerial[1] = 0xFF;
				uSerial[2] = 0xFF;
				uSerial[3] = 0xFF;
			}
		}
	}
	else
	{
		xil_printf("Failed to read serial number.\r\n");
		uSerial[0] = 0xFF;
		uSerial[1] = 0xFF;
		uSerial[2] = 0xFF;
		uSerial[3] = 0xFF;
	}

	// GT 04/06/2015 BASIC SANITY CHECK, IF FAILS TRY TO READ ONE MORE TIME
	if (uSerial[0] != 0x50) // CHECK FOR 'P'
	{
		xil_printf("Trying again to read serial number.\r\n");

		iSuccess = OneWireReadRom(uRom, MB_ONE_WIRE_PORT);

		if (iSuccess == XST_SUCCESS)
		{
			// GT 05/06/2015 CHECK CRC OF ROM TO CONFIRM OK
			uRomCRC = OneWireCrc8(& uRom[0], 0x7);
			if (uRomCRC != uRom[7])
			{
				xil_printf("MB 1-wire CRC incorrect.\r\n");
				uSerial[0] = 0xFF;
				uSerial[1] = 0xFF;
				uSerial[2] = 0xFF;
				uSerial[3] = 0xFF;
			}
			else
			{
				// Read the serial number
				iSuccess = DS2433ReadMem(uRom, 0, uSerial, 4, 0, 0, MB_ONE_WIRE_PORT);

				if (iSuccess == XST_FAILURE)
				{
					xil_printf("Failed to read serial number.\r\n");
					uSerial[0] = 0xFF;
					uSerial[1] = 0xFF;
					uSerial[2] = 0xFF;
					uSerial[3] = 0xFF;
				}
			}
		}
		else
		{
			xil_printf("Failed to read serial number.\r\n");
			uSerial[0] = 0xFF;
			uSerial[1] = 0xFF;
			uSerial[2] = 0xFF;
			uSerial[3] = 0xFF;
		}
	}

	// TO DO: NOT SURE WHAT TO DO HERE FOR MULTICAST
	uFabricMacHigh = 0x0600 | uSerial[0];
	uFabricMacMid = (uSerial[1] << 8) | uSerial[2];

	for (uId = 0; uId < NUM_ETHERNET_INTERFACES; uId++)
	{
		uEnableArpRequests[uId] = ARP_REQUESTS_DISABLE;
		uEthernetLinkUp[uId] = LINK_DOWN;
		uEthernetFabricSubnetMask[uId] = ETHERNET_FABRIC_SUBNET_MASK;
		uEthernetFabricPortAddress[uId] = ETHERNET_FABRIC_PORT_ADDRESS;
		uEthernetSubnet[uId] = ETHERNET_FABRIC_SUBNET;
		uIPIdentification[uId] = 0x7342;

#ifdef DO_40GBE_LOOPBACK_TEST
		xil_printf("Setting all 40GBE MAC addresses same so can test in loopback!\r\n");
		if (uId == 0)
			uFabricMacLow = (uSerial[3] << 8) | uId;
		else
			uFabricMacLow = (uSerial[3] << 8) | 0x1;
#else
		uFabricMacLow = (uSerial[3] << 8) | uId;
#endif

		uEthernetFabricMacHigh[uId] = uFabricMacHigh;
		uEthernetFabricMacMid[uId] = uFabricMacMid;
		uEthernetFabricMacLow[uId] = uFabricMacLow;

		xil_printf("Setting MAC for IF %x TO %x %x %x\r\n", uId, uFabricMacHigh, uFabricMacMid, uFabricMacLow);
		SetFabricSourceMACAddress(uId, uEthernetFabricMacHigh[uId], ((uEthernetFabricMacMid[uId] << 16) | (uEthernetFabricMacLow[uId])));
		//SetFabricSourcePortAddress(uId, uEthernetFabricPortAddress[uId]);

		uDHCPTransactionID[uId] = uId;

		uIGMPState[uId] = IGMP_STATE_NOT_JOINED;
		uIGMPSendMessage[uId] = IGMP_SEND_MESSAGE;
		uCurrentIGMPMessage[uId] = 0x0;

		uEthernetNeedsReset[uId] = NEEDS_RESET;

		iSuccess = SoftReset(uId);

#ifdef DEBUG_PRINT
		if (iSuccess == XST_FAILURE)
			xil_printf("ID: %x Failed to do soft reset\r\n", uId);
		else
		    xil_printf("ID: %x Soft reset successful.\r\n", uId);
#endif

	}

	// PERALEX SERIAL NUMBER
	iSuccess = DS2433ReadMem(uRom, 0, uPxSerial, 3, 7, 0, MB_ONE_WIRE_PORT);

	if (iSuccess == XST_FAILURE)
	{
		xil_printf("Failed to read Px serial number.\r\n");
		uPxSerial[0] = 0xFF;
		uPxSerial[1] = 0xFF;
		uPxSerial[2] = 0xFF;
	}

	uPxSerialNumber = uPxSerial[2] + (uPxSerial[1] << 8) + (uPxSerial[0] << 16);
#ifdef DEBUG_PRINT
	xil_printf("Motherboard Px Serial Number: %d\r\n", uPxSerialNumber);
#endif

}

//=================================================================================
//	UpdateGBEPHYConfiguration
//--------------------------------------------------------------------------------
//	This method updates the configuration of the 1GBE PHY to improve the link
//	compatibility with different NICs. The drivers for some NICs do not support sleep 
// 	reliably resulting in occasional packet loss. Also enable flow control through
//	pause frames to prevent possible packet loss in the Marvell 1GBE PHY. This is equivalent 
//	to setting DIS_SLEEP = '1' and ENA_PAUSE = '1'
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void UpdateGBEPHYConfiguration()
{
	int iSuccess;
	u16 uWriteBytes[4];
	u16 uReadBytes[4];
	u16 uCurrentControlReg;

	// Set the switch to the GBE PHY
    uWriteBytes[0] = ONE_GBE_SWITCH_SELECT;
	iSuccess = WriteI2CBytes(MB_I2C_BUS_ID, PCA9546_I2C_DEVICE_ADDRESS, uWriteBytes, 1);

	if (iSuccess == XST_FAILURE)
		xil_printf("UpdateGBEPHYConfiguration: Failed to open I2C switch.\r\n");

	// Select PAGE 0
	uWriteBytes[0]  = 22; // Address of register to write
	uWriteBytes[1]  = 0;
	uWriteBytes[2]  = 0; // PAGE 0

	iSuccess = WriteI2CBytes(MB_I2C_BUS_ID, GBE_88E1111_I2C_DEVICE_ADDRESS, uWriteBytes, 3);

	if (iSuccess == XST_FAILURE)
		xil_printf("UpdateGBEPHYConfiguration: Failed to select PAGE 0.\r\n");

	// Update PHY SPECIFIC CONTROL REGISTER (16), ENERGY DETECT = "00" (DIS_SLEEP = '1')
	uWriteBytes[0] = 16; // Address of register to write
	uWriteBytes[1] = 0xF0;
	uWriteBytes[2] = 0x78;

	iSuccess = WriteI2CBytes(MB_I2C_BUS_ID, GBE_88E1111_I2C_DEVICE_ADDRESS, uWriteBytes, 3);

	if (iSuccess == XST_FAILURE)
		xil_printf("UpdateGBEPHYConfiguration: Failed to update PHY SPECIFIC CONTROL REG.\r\n");

	// Update AUTO NEGOTIATION ADVERTISEMENT REGISTER (4), support PAUSE (ENA_PAUSE = '1')
	uWriteBytes[0] = 4; // Address of register to write
	uWriteBytes[1] = 0x0D;
	uWriteBytes[2] = 0xE1;

	iSuccess = WriteI2CBytes(MB_I2C_BUS_ID, GBE_88E1111_I2C_DEVICE_ADDRESS, uWriteBytes, 3);

	if (iSuccess == XST_FAILURE)
		xil_printf("UpdateGBEPHYConfiguration: Failed to update AUTO NEGOTIATION ADVERTISEMENT REG.\r\n");

	// Read register 0 to get current configuration
	uWriteBytes[0] = 0; // Address of register to read

	iSuccess = WriteI2CBytes(MB_I2C_BUS_ID, GBE_88E1111_I2C_DEVICE_ADDRESS, uWriteBytes, 1);

	if (iSuccess == XST_FAILURE)
		xil_printf("UpdateGBEPHYConfiguration: Failed to update current read register.\r\n");

	iSuccess = ReadI2CBytes(MB_I2C_BUS_ID, GBE_88E1111_I2C_DEVICE_ADDRESS, uReadBytes, 2);

	if (iSuccess == XST_FAILURE)
		xil_printf("UpdateGBEPHYConfiguration: Failed to read CONTROL REG.\r\n");

	uCurrentControlReg = ((uReadBytes[0] << 8) | uReadBytes[1]);
	xil_printf("Current 1GBE PHY configuration: 0x%x.\r\n", uCurrentControlReg);

	// Trigger a soft reset of 1GBE PHY to update configuration
	// Do a soft reset
	uCurrentControlReg = uCurrentControlReg | 0x8000;

	uWriteBytes[0] = 0; // Address of register to write
	uWriteBytes[1] = ((uCurrentControlReg >> 8) & 0xFF);
	uWriteBytes[2] = (uCurrentControlReg & 0xFF);

	iSuccess = WriteI2CBytes(MB_I2C_BUS_ID, GBE_88E1111_I2C_DEVICE_ADDRESS, uWriteBytes, 3);

	if (iSuccess == XST_FAILURE)
		xil_printf("UpdateGBEPHYConfiguration: Failed to write CONTROL REG.\r\n");

	// Close I2C switch
    uWriteBytes[0] = 0x0;
	iSuccess = WriteI2CBytes(MB_I2C_BUS_ID, PCA9546_I2C_DEVICE_ADDRESS, uWriteBytes, 1);

	if (iSuccess == XST_FAILURE)
		xil_printf("UpdateGBEPHYConfiguration: Failed to close I2C switch.\r\n");

}

//=================================================================================
//	InitialiseEthernetInterfaceParameters
//--------------------------------------------------------------------------------
//	This method configures the Ethernet interfaces with some default values.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void InitialiseQSFPMezzanineLocation()
{
	u32 uReg;
	u32 uMezzanineMask;
	u16 uDeviceRom[8];
	u16 uReadBytes[32];
	int iStatus = XST_SUCCESS;
	u16 uOneWirePort;

	uQSFPMezzanineLocation = 0x0;
	uQSFPMezzaninePresent = QSFP_MEZZANINE_NOT_PRESENT;
	uQSFPMezzanineCurrentTxLed = 0x0;
	uQSFPMezzanineCurrentRxLed = 0x0;
	uQSFPUpdateState = QSFP_UPDATING_TX_LEDS;
	uQSFPUpdateStatusEnable = DO_NOT_UPDATE_QSFP_STATUS;
	uQSFPI2CMicroblazeAccess = QSFP_I2C_MICROBLAZE_ENABLE;
	uQSFPStateCounter = 0;
	uQSFPState = QSFP_STATE_RESET;

	uQSFPCtrlReg = QSFP0_RESET | QSFP1_RESET | QSFP2_RESET | QSFP3_RESET;
	WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);

	uReg = ReadBoardRegister(C_RD_MEZZANINE_STAT_ADDR);

	while ((uQSFPMezzaninePresent == QSFP_MEZZANINE_NOT_PRESENT)&&(uQSFPMezzanineLocation < 0x4))
	{
		uMezzanineMask = 0x1 << uQSFPMezzanineLocation;
		uOneWirePort = uQSFPMezzanineLocation + 0x1;

		// Check if a mezzanine is preset
		if ((uReg & uMezzanineMask) != 0x0)
		{
			// Mezzanine present here, read manufacturer code in 1-wire to see if Peralex board
			iStatus = OneWireReadRom(uDeviceRom, uOneWirePort);

			if (iStatus == XST_SUCCESS)
			{
				iStatus = DS2433ReadMem(uDeviceRom, 0x0, uReadBytes, 0x1, 0x0, 0x0, uOneWirePort);

				if ((iStatus == XST_SUCCESS)&&(uReadBytes[0] == 0x50)) // Check if read 'P'
				{
					xil_printf("Mezzanine %x is a QSFP+ MEZZANINE\r\n", uQSFPMezzanineLocation);
					uQSFPMezzaninePresent = QSFP_MEZZANINE_PRESENT;
				}
				else
				{
					uQSFPMezzanineLocation++;
				}
			}
			else
			{
				uQSFPMezzanineLocation++;
			}
		}
		else
		{
			uQSFPMezzanineLocation++;
		}

	}

	if (uQSFPMezzaninePresent == QSFP_MEZZANINE_NOT_PRESENT)
		xil_printf("Failed to find a QSFP+ MEZZANINE!\r\n");
}

//=================================================================================
//	InitialiseInterruptControllerAndTimer
//--------------------------------------------------------------------------------
//	This method configures the interrupt controller and timer used for DHCP timeouts.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void InitialiseInterruptControllerAndTimer(XTmrCtr * pTimer, XIntc * pInterruptController)
{
	u32 uDHCPTimerOptions;
	int iStatus;

	iStatus = XTmrCtr_Initialize(pTimer, XPAR_TMRCTR_0_DEVICE_ID);

	if (iStatus != XST_SUCCESS)
	   xil_printf("Failed to initialise DHCP retry timer.\r\n");

	iStatus = XIntc_Initialize(pInterruptController, XPAR_INTC_SINGLE_DEVICE_ID);

	if (iStatus == XST_DEVICE_IS_STARTED)
	{
	   XIntc_Stop(pInterruptController);
	   iStatus = XIntc_Initialize(pInterruptController, XPAR_INTC_SINGLE_DEVICE_ID);
	}

	if (iStatus == XST_SUCCESS)
	{
	   iStatus = XIntc_Connect(pInterruptController, XPAR_INTC_0_TMRCTR_0_VEC_ID, (XInterruptHandler) XTmrCtr_InterruptHandler, (void*) pTimer);

	   if (iStatus == XST_SUCCESS)
	   {
		   iStatus =  XIntc_Start(pInterruptController, XIN_REAL_MODE);
		   if (iStatus == XST_SUCCESS)
			   XIntc_Enable(pInterruptController, XPAR_INTC_0_TMRCTR_0_VEC_ID);
		   else
			   xil_printf("Failed to start interrupt controller.\r\n");
	   }
	   else
		   xil_printf("Failed to connect Timer interrupt to interrupt controller.\r\n");
	}
	else
	   xil_printf("Failed to initialise interrupt controller.\r\n");

	microblaze_enable_interrupts();

	XTmrCtr_SetHandler(pTimer, TimerHandler, pTimer);
	uDHCPTimerOptions = XTC_INT_MODE_OPTION | XTC_AUTO_RELOAD_OPTION | XTC_DOWN_COUNT_OPTION;
	XTmrCtr_SetOptions(pTimer, DHCP_RETRY_TIMER_ID, uDHCPTimerOptions);
	XTmrCtr_SetResetValue(pTimer, DHCP_RETRY_TIMER_ID, DHCP_TIMER_RESET_VALUE);
	XTmrCtr_Start(pTimer, DHCP_RETRY_TIMER_ID);

	uIGMPTimerCounter = 0;
	uIGMPTimerCounter = 0;
}

//=================================================================================
//	ReadAndPrintFPGADNA
//--------------------------------------------------------------------------------
//	This method reads and prints out the FPGA DNA value.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void ReadAndPrintFPGADNA()
{
	u32 uDNALow = ReadBoardRegister(C_RD_FPGA_DNA_LOW_ADDR);
	u32 uDNAHigh = ReadBoardRegister(C_RD_FPGA_DNA_HIGH_ADDR);
	u8 uBitShift = 28;
	u8 uNibbleCount;
	u32 uNibble;

	// Print out each nibble in hex format
	xil_printf("FPGA DNA: 0x");

	for (uNibbleCount = 0; uNibbleCount < 8; uNibbleCount++)
	{
		uNibble = (uDNAHigh >> uBitShift) & 0xF;
		xil_printf("%x", uNibble);
		if (uBitShift > 0)
			uBitShift = uBitShift - 4;
	}

	uBitShift = 28;

	for (uNibbleCount = 0; uNibbleCount < 8; uNibbleCount++)
	{
		uNibble = (uDNALow >> uBitShift) & 0xF;
		xil_printf("%x", uNibble);
		if (uBitShift > 0)
			uBitShift = uBitShift - 4;
	}

	xil_printf("\r\n");
}


int main() 
{
	   int iStatus;
	   u32 uReadReg;
#ifdef DEV_PLATFORM
	   u32 uSleepCount;
#endif
	   u8 uEthernetId;
	   u32 uNumWords;
	   u32 uResponsePacketLength;
	   XTmrCtr Timer;
	   XIntc InterruptController;
	   XWdtTb WatchdogTimer;
	   u32 uIGMPGroupAddress;
	   u8 uOKToReboot;
     u16 uDHCPBoundCount[NUM_ETHERNET_INTERFACES] = {0};
     u8 uDHCPBoundTimeout = 0;
#ifdef DO_40GBE_LOOPBACK_TEST
	   u32 uTemp40GBEIPAddress = 0x0A000802;
	   u8 uConfig40GBE[4];
	   uConfig40GBE[0] = 0x1;
	   uConfig40GBE[1] = 0x1;
	   uConfig40GBE[2] = 0x1;
	   uConfig40GBE[3] = 0x1;
#endif

#ifdef DO_1GBE_LOOPBACK_TEST
	   u32 uTemp1GBEIPAddress = 0x0A000702;
	   u8 uConfig1GBE = 0x1;
#endif

     //struct sDHCPObject DHCPContextState[NUM_ETHERNET_INTERFACES];  /* TODO do we have enough stack space???*/
     u8 arrEthId[NUM_ETHERNET_INTERFACES];
     u8 uTempMac[6];
#ifdef DEBUG_PRINT
     u16 uCountDumpStats_DHCP=0;
#endif

	   Xil_ICacheEnable();
	   Xil_DCacheEnable();

	   uFrontPanelTimerCounter = 0x0;
	   uFrontPanelLeds = LED_OFF;

	   uDoReboot = NO_REBOOT;

	   InitI2C(0x0, SPEED_100kHz);
	   InitI2C(0x1, SPEED_400kHz);
	   InitI2C(0x2, SPEED_400kHz);
	   InitI2C(0x3, SPEED_400kHz);
	   InitI2C(0x4, SPEED_400kHz);

#ifdef DEV_PLATFORM
	   iStatus = I2CProgramRefClkOsc();
	   if (iStatus == 0)
	   {
		   xil_printf("Programming Refclk OSC success\r\n");
	   }
	   else
	   {
		   xil_printf("Programming Refclk OSC failed\r\n");
	   }
#endif

	   xil_printf("\r\n---Entering main---\n\r");
	   xil_printf("Embedded software version: %d.%d.%d\n\r", EMBEDDED_SOFTWARE_VERSION_MAJOR,
                                                           EMBEDDED_SOFTWARE_VERSION_MINOR,
                                                           EMBEDDED_SOFTWARE_VERSION_PATCH);
	   xil_printf("Running ELF version: %s\n\r", VENDOR_ID);

#ifdef DEV_PLATFORM
	   iStatus = I2CProgramSFPClkOsc();
	   if (iStatus == 0)
	   {
		   xil_printf("Programming SFP OSC success\r\n");
	   }
	   else
	   {
		   xil_printf("Programming SFP OSC failed\r\n");
	   }

	   // Sleep for five seconds because this is a dangerous time for the
	   // system clock
	   for (uSleepCount = 0; uSleepCount < 5000; uSleepCount++)
		   Delay(1000);
#endif

	   // Enable the watchdog timer
	   xil_printf("Initialising the WDT.\r\n");

	   iStatus = XWdtTb_Initialize(& WatchdogTimer, XPAR_WDTTB_0_DEVICE_ID);

	   // GT 31/03/2017 FIX DETECTION OF WHETHER PREVIOUS RESET WAS RESULT OF WATCHDOG
	   if (iStatus == XST_DEVICE_IS_STARTED)
	   {
		   if (XWdtTb_IsWdtExpired(& WatchdogTimer))
			   xil_printf("Previous reset result of WDT.\r\n");

		   XWdtTb_Stop(& WatchdogTimer);

		   iStatus = XWdtTb_Initialize(& WatchdogTimer, XPAR_WDTTB_0_DEVICE_ID);

		   XWdtTb_Start(& WatchdogTimer);
	   }
	   else if (iStatus == XST_SUCCESS)
	   {
		   if (XWdtTb_IsWdtExpired(& WatchdogTimer))
			   xil_printf("Previous reset result of WDT.\r\n");

		   XWdtTb_Start(& WatchdogTimer);
	   }
	   else
		   xil_printf("Failed to initialise the WDT.\r\n");

	   FinishedBootingFromSdram();

	   // GT 7/3/2016 DIS_SLEEP = '1' and ENA_PAUSE = '1'
	   UpdateGBEPHYConfiguration();

	   xil_printf("Waiting for 1GBE SGMII to come out of reset...\r\n");

	   do
	   {
		   uReadReg = ReadBoardRegister(C_RD_BRD_CTL_STAT_0_ADDR);
	   }while((uReadReg & 0x1) != 0x1);

	   InitialiseInterruptControllerAndTimer(& Timer, & InterruptController);

	   InitialiseQSFPMezzanineLocation();

	   InitialiseEthernetInterfaceParameters();

     /* set bit#1 in C_WR_BRD_CTL_STAT_1_ADDR to 1 to connect 40gbe to user fabric */
     WriteBoardRegister(C_WR_BRD_CTL_STAT_1_ADDR, 0x2);

	   iStatus = XST_SUCCESS;

	   ReadAndPrintFPGADNA();

     /* DHCP State initializations for each interface */
     /* TODO: perhaps create an inline function for the following to neaten up code */
     /* the first 5 octets of the mac address /should/ never change across interfaces */
     uTempMac[0] = (uEthernetFabricMacHigh[0] >> 8) & 0xff;
     uTempMac[1] = (uEthernetFabricMacHigh[0]     ) & 0xff;
     uTempMac[2] = (uEthernetFabricMacMid[0]  >> 8) & 0xff;
     uTempMac[3] = (uEthernetFabricMacMid[0]      ) & 0xff;
     uTempMac[4] = (uEthernetFabricMacLow[0]  >> 8) & 0xff;

     u8 uTempHostNameString[16] = "skarab";   /* 15 chars plus '/0'. To be appended just now with partial mac & i/f. */
     u8 uTempDigit;

     /* stringify mac and append to hostname ("skarab" - see initialization above ) */

     uTempDigit = ((uEthernetFabricMacMid[0] >> 8) & 0xff) / 0x10;  /* upper digit of upper octet of mac-mid */
     uTempHostNameString[6] = uTempDigit > 9 ? ((uTempDigit - 10) + 0x41) : (uTempDigit + 0x30);

     uTempDigit = ((uEthernetFabricMacMid[0] >> 8) & 0xff) % 0x10;  /* lower digit of upper octet of mac-mid */
     uTempHostNameString[7] = uTempDigit > 9 ? ((uTempDigit - 10) + 0x41) : (uTempDigit + 0x30);

     uTempDigit = ((uEthernetFabricMacMid[0]) & 0xff) / 0x10;  /* upper digit of lower octet of mac-mid */
     uTempHostNameString[8] = uTempDigit > 9 ? ((uTempDigit - 10) + 0x41) : (uTempDigit + 0x30);

     uTempDigit = ((uEthernetFabricMacMid[0]) & 0xff) % 0x10;  /* lower digit of lower octet of mac-mid */
     uTempHostNameString[9] = uTempDigit > 9 ? ((uTempDigit - 10) + 0x41) : (uTempDigit + 0x30);

     uTempDigit = ((uEthernetFabricMacLow[0] >> 8) & 0xff) / 0x10;  /* upper digit of upper octet of mac-low */
     uTempHostNameString[10] = uTempDigit > 9 ? ((uTempDigit - 10) + 0x41) : (uTempDigit + 0x30);

     uTempDigit = ((uEthernetFabricMacLow[0] >> 8) & 0xff) % 0x10;  /* lower digit of upper octet of mac-low */
     uTempHostNameString[11] = uTempDigit > 9 ? ((uTempDigit - 10) + 0x41) : (uTempDigit + 0x30);


     uTempHostNameString[12] = '-';

     for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++){
       arrEthId[uEthernetId] = uEthernetId;
       
       /* 6th octet of mac should equal id anyway */
       uTempMac[5] = uEthernetFabricMacLow[uEthernetId] & 0xff;
       /* fill in interface number in host name and terminate string */
       uTempHostNameString[13] = (uEthernetId / 10) + 48;  /* tens digit of interface id*/
       uTempHostNameString[14] = (uEthernetId % 10) + 48;  /* unit digit of interface id*/
       uTempHostNameString[15] = '\0';  /* unit digit of interface id*/

       uDHCPInit(&DHCPContextState[uEthernetId], (u8 *) uReceiveBuffer, (512 * 4), (u8 *) uTransmitBuffer, (256 * 4), uTempMac);
       eventDHCPOnMsgBuilt(&DHCPContextState[uEthernetId], &vSendDHCPMsg, &arrEthId[uEthernetId]);
       eventDHCPOnLeaseAcqd(&DHCPContextState[uEthernetId], &vSetInterfaceConfig, &arrEthId[uEthernetId]);
       vDHCPSetHostName(&DHCPContextState[uEthernetId], (char *) &uTempHostNameString);
       /* uDHCPSetStateMachineEnable(&DHCPContextState[uEthernetId], TRUE); */
     }

	   while(1)
	   {
		   if (uQSFPMezzaninePresent == QSFP_MEZZANINE_PRESENT)
			   UpdateQSFPStatus();

		   for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++)
		   {
			   UpdateEthernetLinkUpStatus(uEthernetId);

			   if (uEthernetLinkUp[uEthernetId] == LINK_UP)
			   {
					uNumWords = GetHostReceiveBufferLevel(uEthernetId);
					if (uNumWords != 0)
					{
					   // Read packet into receive buffer
					   //xil_printf("Rd pkt.\r\n");
					   iStatus  = ReadHostPacket(uEthernetId, & uReceiveBuffer[0], uNumWords);
             /* TODO remove the following inline data declarations */
             u16 *buffer = (u16*) uReceiveBuffer;

					   if (iStatus == XST_SUCCESS)
					   {
						   //xil_printf("Pkt hndlr.\r\n");
						   iStatus = EthernetRecvHandler(uEthernetId, uNumWords, &uResponsePacketLength);
					   }

					   if (iStatus == XST_SUCCESS)
					   {
						   // Send the response packet now
						   uResponsePacketLength = (uResponsePacketLength >> 2);
						   iStatus = TransmitHostPacket(uEthernetId, & uTransmitBuffer[0], uResponsePacketLength);
					   } else {

               /* DHCP new */
               /* TODO remove the following inline data declarations */
               int size = uNumWords << 1;     /* 16bit words */
               int i;

               for (i = 0; i < size; i++){
                 buffer[i] = Xil_EndianSwap16(buffer[i]);
               }

               /* validate and set flag */
               if (uDHCPMessageValidate(&DHCPContextState[uEthernetId]) == DHCP_RETURN_OK){
#ifdef DEBUG_PRINT
                 xil_printf("DHCP [%02x] valid packet received!\r\n", uEthernetId);
#endif
                 uDHCPSetGotMsgFlag(&DHCPContextState[uEthernetId]);
                 uFlagRunTask_DHCP = 1;   /* short-circuit the task logic and run DHCP task on next main loop iteration */
               }
               /* DHCP new */
             }
					}

#ifdef DO_40GBE_LOOPBACK_TEST
					// Testing 40GBE in loopback so won't get an IP address from DHCP
					if (uEthernetId != 0x0)
					{
						if (uConfig40GBE[uEthernetId - 1] == 0x1)
						{
							uConfig40GBE[uEthernetId - 1] = 0x0;
#ifdef DEBUG_PRINT
							xil_printf("ID: %x Setting IP address to: %x\r\n", uEthernetId, uTemp40GBEIPAddress);
#endif

							uDHCPState[uEthernetId] = DHCP_STATE_COMPLETE;

							uEthernetFabricIPAddress[uEthernetId] = uTemp40GBEIPAddress;

							SetFabricSourceIPAddress(uEthernetId, uEthernetFabricIPAddress[uEthernetId]);

							// Add an entry for own IP address in ARP cache table for loopback testing
#ifdef DEBUG_PRINT
							xil_printf("ARP ENTRY ID: %x IP: %x MAC: %x %x %x\r\n", uEthernetId, uTemp40GBEIPAddress, uEthernetFabricMacHigh[uEthernetId], uEthernetFabricMacMid[uEthernetId], uEthernetFabricMacLow[uEthernetId]);
#endif
							ProgramARPCacheEntry(uEthernetId, (uTemp40GBEIPAddress & 0xFF), uEthernetFabricMacHigh[uEthernetId], ((uEthernetFabricMacMid[uEthernetId] << 16) | uEthernetFabricMacLow[uEthernetId]));

#ifdef DEBUG_PRINT
							xil_printf("Enabling 40GBE ETH MAC FPGA fabric interface...\r\n");
#endif
							EnableFabricInterface(uEthernetId, 0x1);
						}
					}
#endif

#ifdef DO_1GBE_LOOPBACK_TEST
					// Testing 1GBE in loopback so won't get an IP address from DHCP
					if ((uConfig1GBE == 0x1)&&(uEthernetId == 0x0))
					{
						uConfig1GBE = 0x0;
#ifdef DEBUG_PRINT
						xil_printf("ID: %x Setting IP address to: %x\r\n", uEthernetId, uTemp1GBEIPAddress);
#endif

						uDHCPState[uEthernetId] = DHCP_STATE_COMPLETE;

						uEthernetFabricIPAddress[uEthernetId] = uTemp1GBEIPAddress;

						SetFabricSourceIPAddress(uEthernetId, uEthernetFabricIPAddress[uEthernetId]);

						// Add an entry for own IP address in ARP cache table for loopback testing
#ifdef DEBUG_PRINT
						xil_printf("ARP ENTRY ID: %x IP: %x MAC: %x %x %x\r\n", uEthernetId, uTemp1GBEIPAddress, uEthernetFabricMacHigh[uEthernetId], uEthernetFabricMacMid[uEthernetId], uEthernetFabricMacLow[uEthernetId]);
#endif

						ProgramARPCacheEntry(uEthernetId, (uTemp1GBEIPAddress & 0xFF), uEthernetFabricMacHigh[uEthernetId], ((uEthernetFabricMacMid[uEthernetId] << 16) | uEthernetFabricMacLow[uEthernetId]));

#ifdef DEBUG_PRINT
						xil_printf("Enabling 1GBE ETH MAC FPGA fabric interface...\r\n");
#endif
						EnableFabricInterface(uEthernetId, 0x1);
					}
#endif 

					if (uIGMPSendMessage[uEthernetId] == IGMP_SEND_MESSAGE)
					{
						if (uIGMPState[uEthernetId] == IGMP_STATE_JOINED_GROUP)
						{
							// Send IGMP membership reports for each IP in group
							if (uCurrentIGMPMessage[uEthernetId] <= (~uEthernetFabricMultiCastIPAddressMask[uEthernetId]))
							{
								uIGMPGroupAddress = (uEthernetFabricMultiCastIPAddress[uEthernetId] & uEthernetFabricMultiCastIPAddressMask[uEthernetId]) | uCurrentIGMPMessage[uEthernetId];
								CreateIGMPPacket(uEthernetId, (u8*) uTransmitBuffer, & uResponsePacketLength, IGMP_MEMBERSHIP_REPORT, uIGMPGroupAddress);
								uResponsePacketLength = (uResponsePacketLength >> 2);
								iStatus =  TransmitHostPacket(uEthernetId, & uTransmitBuffer[0], uResponsePacketLength);
								uCurrentIGMPMessage[uEthernetId]++;
							}
							else
								uIGMPSendMessage[uEthernetId] = IGMP_DONE_SENDING_MESSAGE;

						}
						else if (uIGMPState[uEthernetId] == IGMP_STATE_LEAVING)
						{
							// Send IGMP leave reports for each IP in group
							if (uCurrentIGMPMessage[uEthernetId] <= (~uEthernetFabricMultiCastIPAddressMask[uEthernetId]))
							{
								uIGMPGroupAddress = (uEthernetFabricMultiCastIPAddress[uEthernetId] & uEthernetFabricMultiCastIPAddressMask[uEthernetId]) | uCurrentIGMPMessage[uEthernetId];
								CreateIGMPPacket(uEthernetId, (u8*) uTransmitBuffer, & uResponsePacketLength, IGMP_LEAVE_REPORT, uIGMPGroupAddress);
								uResponsePacketLength = (uResponsePacketLength >> 2);
								iStatus =  TransmitHostPacket(uEthernetId, & uTransmitBuffer[0], uResponsePacketLength);
								uCurrentIGMPMessage[uEthernetId]++;
							}
							else
							{
								// Once finished sending all the LEAVE messages, put into IDLE state
								uIGMPState[uEthernetId] = IGMP_STATE_NOT_JOINED;
								uIGMPSendMessage[uEthernetId] = IGMP_DONE_SENDING_MESSAGE;
							}
						}

					}

			   }
		   }

      /* simple interrupt driven multi-tasking scheduler */

      /* is it time... */
      /* ... to run the dhcp task */
      if (uFlagRunTask_DHCP){
        uFlagRunTask_DHCP = 0;     /* reset task flag */
        for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++){
          uDHCPStateMachine(&DHCPContextState[uEthernetId]);
        }
#ifdef DEBUG_PRINT
        uCountDumpStats_DHCP++;
        if (uCountDumpStats_DHCP == 3000){
          uCountDumpStats_DHCP=0;
          /* dump dhcp stats to terminal once in a while */
          for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++){
            xil_printf("DHCP[%d] stats-> rx: %d, tx: %d, err: %d, invalid: %d, retry: %d\r\n", uEthernetId, DHCPContextState[uEthernetId].uDHCPRx,
                DHCPContextState[uEthernetId].uDHCPTx, DHCPContextState[uEthernetId].uDHCPErrors,
                DHCPContextState[uEthernetId].uDHCPInvalid, DHCPContextState[uEthernetId].uDHCPRetries);
          }
        }
#endif
      }

      /* ... time to do ARP requests? */
			if (uUpdateArpRequests == ARP_REQUEST_UPDATE){
			   ArpRequestHandler();
      }

      /* is it time to run the lldp task? */
      if(uFlagRunTask_LLDP){
        for(uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++){
          iStatus = uLLDPBuildPacket(uEthernetId, (u8*) uTransmitBuffer, &uResponsePacketLength);

          if(iStatus == XST_SUCCESS){
            u32 size = uResponsePacketLength >> 1; /* 16 bit words */
            u16 * buffer = (u16*)uTransmitBuffer;

            for(u32 uIndex = 0; uIndex < size; uIndex++){
              buffer[uIndex] = Xil_EndianSwap16(buffer[uIndex]);
            }
            size = size >> 1; /* 32 bit words*/
            iStatus = TransmitHostPacket(uEthernetId, (u32*) &buffer[0], size);
          }
        }
        uFlagRunTask_LLDP = 0;	
      }

      /* keep track of how long we have been "unbound" w.r.t. dhcp - if too long, reset and reload image from sdram */
      if(uFlagRunTask_CheckDHCPBound){
        uFlagRunTask_CheckDHCPBound = 0;
        uDHCPBoundTimeout = 0;
        for(uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++){
          /* TODO: create API function to get state */
          if (DHCPContextState[uEthernetId].tDHCPCurrentState < BOUND){
            if (uDHCPBoundCount[uEthernetId] < DHCP_BOUND_COUNTER_VALUE){ /*  prevent overflows */
              uDHCPBoundCount[uEthernetId]++;   /* keep track of how long we've been unbound */
            }
          } else {
            uDHCPBoundCount[uEthernetId] = 0; /* reset the counter if we have progressed passed the BOUND state at any point */
          }
          if (uDHCPBoundCount[uEthernetId] >= DHCP_BOUND_COUNTER_VALUE){
            uDHCPBoundTimeout++;
          }
        }
        /* if we timeout on all the interfaces, line up a reset and reload the image in SDRAM */
        if(uDHCPBoundTimeout >= NUM_ETHERNET_INTERFACES){
          SetOutputMode(SDRAM_READ_MODE, 0x0); // Release flash bus when about to do a reboot
          ResetSdramReadAddress();
          AboutToBootFromSdram();
          uDoReboot = REBOOT_REQUESTED;
#ifdef DEBUG_PRINT
          xil_printf("DHCP: RESET - All I/F's timed out!\n\r");
#endif
        }
      }


      if (uDoReboot == REBOOT_REQUESTED)
      {
        // Only do a reboot if all the Ethernet interfaces are no longer part of groups
        uOKToReboot = 1;

        for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++)
        {
          if (uIGMPState[uEthernetId] != IGMP_STATE_NOT_JOINED){
            uOKToReboot = 0;
          }
        }
        if (uOKToReboot == 1){
          IcapeControllerInSystemReconfiguration();
        }

      }

      // Pat the watchdog
      XWdtTb_RestartWdt(& WatchdogTimer);
     }

     xil_printf("---Exiting main---\n\r");
     Xil_DCacheDisable();
     Xil_ICacheDisable();
     return 0;
}


static int vSendDHCPMsg(struct sDHCPObject *pDHCPObjectPtr, void *pUserData){
  u8 uEthernetId;
  u8 uReturnValue;
  u32 size;
  u16 *buffer;
  u32 uIndex;

  size = (u32) pDHCPObjectPtr->uDHCPMsgSize;    /* bytes */
  buffer = (u16 *) pDHCPObjectPtr->pUserTxBufferPtr;

  size = size >> 1;     /* 16bit words */

  for (uIndex = 0; uIndex < size; uIndex++){
    buffer[uIndex] = Xil_EndianSwap16(buffer[uIndex]);
  }

  uEthernetId = * ((u8 *) pUserData);
  size = size >> 1;   /*  32-bit words */
  uReturnValue = TransmitHostPacket(uEthernetId, (u32 *) buffer, size);
  if (uReturnValue == XST_SUCCESS){
    xil_printf("DHCP [%02x] sent DHCP packet with xid 0x%x\n\r", uEthernetId, pDHCPObjectPtr->uDHCPXidCached);
  } else {
    xil_printf("DHCP [%02x] FAILED to send DHCP packet with xid 0x%x\n\r", uEthernetId, pDHCPObjectPtr->uDHCPXidCached);
  }

  return uReturnValue;
}


static int vSetInterfaceConfig(struct sDHCPObject *pDHCPObjectPtr, void *pUserData){
  u32 ip = 0;
  u32 netmask = 0;
  u8 id;

  id = * ((u8 *) pUserData);
  ip = (pDHCPObjectPtr->arrDHCPAddrYIPCached[0] << 24) |
       (pDHCPObjectPtr->arrDHCPAddrYIPCached[1] << 16) |
       (pDHCPObjectPtr->arrDHCPAddrYIPCached[2] << 8 ) |
        pDHCPObjectPtr->arrDHCPAddrYIPCached[3];

  netmask = (pDHCPObjectPtr->arrDHCPAddrSubnetMask[0] << 24) |
            (pDHCPObjectPtr->arrDHCPAddrSubnetMask[1] << 16) |
            (pDHCPObjectPtr->arrDHCPAddrSubnetMask[2] << 8 ) |
             pDHCPObjectPtr->arrDHCPAddrSubnetMask[3];

  xil_printf("DHCP [%02x] Setting IP address to: %u.%u.%u.%u\r\n", id, ((ip >> 24) & 0xFF),
      ((ip >> 16) & 0xFF),
      ((ip >> 8) & 0xFF),
      (ip & 0xFF));

  xil_printf("DHCP [%02x] Setting netmask to: %u.%u.%u.%u\r\n", id, ((netmask >> 24) & 0xFF),
      ((netmask >> 16) & 0xFF),
      ((netmask >> 8) & 0xFF),
      (netmask & 0xFF));

  uEthernetFabricIPAddress[id] = ip;
  /* uEthernetSubnet[id] = (ip & 0xFFFFFF00); */
  uEthernetSubnet[id] = (ip & netmask);

  uEthernetGatewayIPAddress[id] = (pDHCPObjectPtr->arrDHCPAddrRoute[0] << 24) |
                                  (pDHCPObjectPtr->arrDHCPAddrRoute[1] << 16) |
                                  (pDHCPObjectPtr->arrDHCPAddrRoute[2] << 8 ) |
                                   pDHCPObjectPtr->arrDHCPAddrRoute[3];

  ProgramARPCacheEntry(id, (ip & 0xFF), uEthernetFabricMacHigh[id], ((uEthernetFabricMacMid[id] << 16) | uEthernetFabricMacLow[id]));

	SetFabricSourceIPAddress(id, ip);

  SetFabricNetmask(id, netmask);

  SetFabricGatewayARPCacheAddress(id, pDHCPObjectPtr->arrDHCPAddrRoute[3]);

  uEnableArpRequests[id] = ARP_REQUESTS_ENABLE;

  /* legacy dhcp states */
  uDHCPState[id] = DHCP_STATE_COMPLETE;

  EnableFabricInterface(id, 1);
  uFlagRunTask_LLDP = 1;
  return 0;
}

