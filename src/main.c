/**------------------------------------------------------------------------------
*  FILE NAME            : main.c
* ------------------------------------------------------------------------------
*  COMPANY              : PERALEX ELECTRONIC (PTY) LTD
* ------------------------------------------------------------------------------
*  COPYRIGHT NOTICE :
*
*  The copyright, manufacturing and patent rights stemming from this
*  document in any form are vested in PERALEX ELECTRONICS (PTY) LTD.
*
*  (c) Peralex 2011
*
*  PERALEX ELECTRONICS (PTY) LTD has ceded these rights to its clients
*  where contractually agreed.
* ------------------------------------------------------------------------------
*  DESCRIPTION :
*
*  This file contains contains the top level functions for the ROACH3 uBlaze
*  embedded processor.
* ------------------------------------------------------------------------------*/

#include <stdio.h>
#include "xparameters.h"
#include "xil_cache.h"
#include "xintc.h"
#include "xwdttb.h"

#include "register.h"
#include "delay.h"
#include "eth_mac.h"
#include "flash_sdram_controller.h"
#include "icape_controller.h"
#include "isp_spi_controller.h"
#include "one_wire.h"
#include "i2c_master.h"
#include "constant_defs.h"
#include "eth_sorter.h"
#include "sensors.h"
#include "improved_read_write.h"
#include "invalid_nack.h"
#include "dhcp.h"
#include "lldp.h"

/* local function prototypes */
static int vSendDHCPMsg(struct sDHCPObject *pDHCPObjectPtr, void *pUserData);
void vSendLLDPPacket(u8 uEthernetId, u8 *pTransmitBuffer, u32 *uResponseLength);
static int vSetInterfaceConfig(struct sDHCPObject *pDHCPObjectPtr, void *pUserData);

/* temp global definition */
static volatile u8 uFlagRunTask_DHCP = 0;
static volatile u8 uFlagRunTask_LLDP = 0;
static struct sDHCPObject DHCPContextState[NUM_ETHERNET_INTERFACES];  /* TODO can we narrow down the scope of this data? */

//=================================================================================
//	TimerHandler
//--------------------------------------------------------------------------------
//	This method handles the interrupts generated by the Timer.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	CallBackRef			IN	Reference to timer object
//	uTimerCounterNumber	IN	There are two timers inside the timer object
//
//	Return
//	------
//	None
//=================================================================================
void TimerHandler(void * CallBackRef, u8 uTimerCounterNumber)
{
	u8 uIndex;
	u8 u40GbE1_Dhcp_En;
	u8 u40GbE2_Dhcp_En;
	u8 u40GbE3_Dhcp_En;
	u8 u40GbE4_Dhcp_En;
	u8 u40GbE1_Link_Up;
	u8 u40GbE2_Link_Up;
	u8 u40GbE3_Link_Up;
	u8 u40GbE4_Link_Up;

	// Every 100 ms, send another ARP request
	uUpdateArpRequests = ARP_REQUEST_UPDATE;
  
 /* set the lldp task flag every 100ms */
  uFlagRunTask_LLDP = 1;
	//LLDP every 10 seconds (timer every 100 ms)
	if(uLLDPTimerCounter == 0x64)
	{
		uLLDPTimerCounter = 0x0;

		for(uIndex = 0; uIndex < NUM_ETHERNET_INTERFACES; uIndex++)
		{
			uLLDPRetryTimer[uIndex] = LLDP_RETRY_ENABLED;
		}
	}
	else
		uLLDPTimerCounter++;


  /* set the dhcp task flag every 100ms which in turn runs dhcp state machine */
  uFlagRunTask_DHCP = 1;

	// DHCP every 10 seconds (timer every 100 ms)
	if (uDHCPTimerCounter == 0x64)
	{
		uDHCPTimerCounter = 0x0;

		for (uIndex = 0; uIndex < NUM_ETHERNET_INTERFACES; uIndex++)
		{
      /* TODO verify if we can remove these */
			//uDHCPRetryTimer[uIndex] = DHCP_RETRY_ENABLED;
			//uEthernetNeedsReset[uIndex] = NEEDS_RESET;

			// Send out ARP requests every 60 seconds
			if (uIGMPTimerCounter == 0x5)
			{
				uIGMPSendMessage[uIndex] = IGMP_SEND_MESSAGE;
				uCurrentIGMPMessage[uIndex] = 0x0;
			}
		}

		// Only send IGMP message reports every 60 seconds
		if (uIGMPTimerCounter == 0x5)
			uIGMPTimerCounter = 0;
		else
			uIGMPTimerCounter++;

	}
	else
		uDHCPTimerCounter++;

	uQSFPUpdateStatusEnable = UPDATE_QSFP_STATUS;

	if (uQSFPStateCounter == 0x1)
	{
		if (uQSFPState == QSFP_STATE_RESET)
		{
			uQSFPStateCounter++;
			uQSFPState = QSFP_STATE_BOOTLOADER_VERSION_WRITE_MODE;
		}
	}
	// Allow 3 seconds for QSFP+ to be ready
	else if (uQSFPStateCounter == 0x1E)
	{
		if (uQSFPState == QSFP_STATE_STARTING_APPLICATION_MODE)
		{
			uQSFPState = QSFP_STATE_APPLICATION_MODE;
		}
	}
	else
		uQSFPStateCounter++;

    //if 40GbE link 1 is up enable link else disable link
	if(uEthernetLinkUp[1] == LINK_UP)
	{
		u40GbE1_Link_Up = 0x01;
		//if 40GbE DHCP is complete then set true else false
		if (uDHCPState[1] == DHCP_STATE_COMPLETE)
		{
			u40GbE1_Dhcp_En = 0x01;
		}
		else
		{
			u40GbE1_Dhcp_En = 0x00;
		}
	}
	else
	{
		u40GbE1_Link_Up = 0x00;
		u40GbE1_Dhcp_En = 0x00;
	}

    //if 40GbE link 2 is up enable link else disable link
	if(uEthernetLinkUp[2] == LINK_UP)
	{
		u40GbE2_Link_Up = 0x01;
		//if 40GbE DHCP is complete then set true else false
		if (uDHCPState[2] == DHCP_STATE_COMPLETE)
		{
			u40GbE2_Dhcp_En = 0x01;
		}
		else
		{
			u40GbE2_Dhcp_En = 0x00;
		}
	}
	else
	{
		u40GbE2_Link_Up = 0x00;
		u40GbE2_Dhcp_En = 0x00;
	}

    //if 40GbE link 3 is up enable link else disable link
	if(uEthernetLinkUp[3] == LINK_UP)
	{
		u40GbE3_Link_Up = 0x01;
		//if 40GbE DHCP is complete then set true else false
		if (uDHCPState[3] == DHCP_STATE_COMPLETE)
		{
			u40GbE3_Dhcp_En = 0x01;
		}
		else
		{
			u40GbE3_Dhcp_En = 0x00;
		}
	}
	else
	{
		u40GbE3_Link_Up = 0x00;
		u40GbE3_Dhcp_En = 0x00;
	}

    //if 40GbE link 4 is up enable link else disable link
	if(uEthernetLinkUp[4] == LINK_UP)
	{
		u40GbE4_Link_Up = 0x01;
		//if 40GbE DHCP is complete then set true else false
		if (uDHCPState[4] == DHCP_STATE_COMPLETE)
		{
			u40GbE4_Dhcp_En = 0x01;
		}
		else
		{
			u40GbE4_Dhcp_En = 0x00;
		}
	}
	else
	{
		u40GbE4_Link_Up = 0x00;
		u40GbE4_Dhcp_En = 0x00;
	}

	uFrontPanelLedsValue = u40GbE4_Link_Up <<7 | u40GbE4_Dhcp_En <<6 | u40GbE3_Link_Up <<5 | u40GbE3_Dhcp_En <<4 | u40GbE2_Link_Up<<3 | u40GbE2_Dhcp_En<<2 | u40GbE1_Link_Up<<1 | u40GbE1_Dhcp_En;
	WriteBoardRegister(C_WR_FRONT_PANEL_STAT_LED_ADDR, uFrontPanelLedsValue);

/*  // Flash front panel LEDS until 1GBE has completed DHCP
	if (uDHCPState[0] != DHCP_STATE_COMPLETE)
	{
		uDHCPCompleteSetLeds = FALSE;
		if (uFrontPanelTimerCounter == 0xA)
		{
			if (uFrontPanelLeds == LED_OFF)
			{
				uFrontPanelLeds = LED_ON;
				WriteBoardRegister(C_WR_FRONT_PANEL_STAT_LED_ADDR, 0xFF);
			}
			else
			{
				uFrontPanelLeds = LED_OFF;
				WriteBoardRegister(C_WR_FRONT_PANEL_STAT_LED_ADDR, 0x00);
			}

			uFrontPanelTimerCounter = 0x0;
		}
		else
			uFrontPanelTimerCounter++;
	}
	else
	{
		if (uDHCPCompleteSetLeds == FALSE)
		{
			uDHCPCompleteSetLeds = TRUE;
			uFrontPanelLeds = LED_ON;
			WriteBoardRegister(C_WR_FRONT_PANEL_STAT_LED_ADDR, 0xFF);
		}
	}
*/

}



//=================================================================================
//	EthernetRecvHandler
//--------------------------------------------------------------------------------
//	This method processes a packet stored in uReceiveBuffer.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	uId			IN		ID of network interface that packet was received from
//	uNumWords	IN		Packet size in 32 bit words
//	uResponsePacketLength	OUT	Length of response packet in bytes
//
//	Return
//	------
//	XST_SUCCESS if successful
//=================================================================================
int EthernetRecvHandler(u8 uId, u32 uNumWords, u32 * uResponsePacketLengthBytes)
{
	// L2 - Ethernet
	// L3 - IP(v4) / ARP
	// L4 - UDP
	// L5 - command protocol
	u32 uL2PktLen;
	u32 uL3PktLen;
	u32 uL4PktLen;
	u32 uL5PktLen;
	u8 *pL2Ptr;
	u8 *pL3Ptr;
	u8 *pL4Ptr;
	u8 *pL5Ptr;
	u8 *uResponsePacketPtr;
	u32 uResponseLength;

	uResponsePacketPtr = (u8*) (uTransmitBuffer);
	uResponsePacketPtr = uResponsePacketPtr + sizeof(sEthernetHeaderT) + sizeof(sIPV4HeaderT) + sizeof(sUDPHeaderT);

	struct sEthernetHeader *EthHdr;
	u32 uL3Proto;
	u32 uL3TOS;
	u32 uUdpSrcPort;
	u32 uUdpDstPort;
	int iStatus;

	// Check we have enough data to proceed: i.e. at least valid Ethernet header
	uL2PktLen = uNumWords * 4;

	if (uL2PktLen < sizeof(struct sEthernetHeader))
		return XST_FAILURE;

	pL2Ptr = (u8 *) (uReceiveBuffer);
	EthHdr = (struct sEthernetHeader *) pL2Ptr;

	// Cache MAC source address for response
	uResponseMacHigh = EthHdr->uSourceMacHigh;
	uResponseMacMid = EthHdr->uSourceMacMid;
	uResponseMacLow = EthHdr->uSourceMacLow;

	pL3Ptr = pL2Ptr + sizeof(struct sEthernetHeader);
	uL3PktLen = uL2PktLen - sizeof(struct sEthernetHeader);

	// TO DO: HANDLE ALL NON-IP/UDP PACKETS HERE
	if (EthHdr->uEthernetType == ETHERNET_TYPE_ARP)
	{

		iStatus = CheckArpRequest(uId, uEthernetFabricIPAddress[uId], uL3PktLen, pL3Ptr);
		if (iStatus == XST_SUCCESS)
		{
#ifdef DEBUG_PRINT
			//xil_printf("ARP packet received!\r\n");
#endif
			ArpHandler(uId, ARP_RESPONSE, pL3Ptr, (u8 *) uTransmitBuffer, uResponsePacketLengthBytes, 0x0);

			return XST_SUCCESS;
		}
		else
			return XST_FAILURE;

	}
	else if (EthHdr->uEthernetType == ETHERNET_TYPE_IPV4)
	{

		//xil_printf("IP packet received!\r\n");
		iStatus = CheckIPV4Header(uEthernetFabricIPAddress[uId], uEthernetFabricSubnetMask[uId], uL3PktLen, pL3Ptr);

		if (iStatus == XST_SUCCESS)
		{

			pL4Ptr = ExtractIPV4FieldsAndGetPayloadPointer(pL3Ptr, &uL4PktLen, &uResponseIPAddr, &uL3Proto, &uL3TOS);

			if ((uL3Proto == IP_PROTOCOL_ICMP)&&(uL3TOS == IP_PING_TOS))
			{
				iStatus = CheckICMPHeader(uL4PktLen, pL4Ptr);

				if (iStatus == XST_SUCCESS)
				{
#ifdef DEBUG_PRINT
					//xil_printf("ICMP packet received!\r\n");
#endif
					ICMPHandler(uId, pL4Ptr, uL4PktLen, (u8 *) uTransmitBuffer, uResponsePacketLengthBytes);
					return XST_SUCCESS;

				}
				else
					return XST_FAILURE;
			}
			else if (uL3Proto == IP_PROTOCOL_UDP)
			{

				//xil_printf("UDP packet received!\r\n");

				iStatus = CheckUdpHeader(pL3Ptr, uL4PktLen, pL4Ptr);
				if (iStatus == XST_SUCCESS)
				{
					pL5Ptr = ExtractUdpFieldsAndGetPayloadPointer(pL4Ptr,& uL5PktLen, & uUdpSrcPort, & uUdpDstPort);

					uResponseUDPPort = uUdpSrcPort;

					// Command protocol
					if (uUdpDstPort == ETHERNET_CONTROL_PORT_ADDRESS)
					{
						iStatus = CommandSorter(pL5Ptr, uL5PktLen, uResponsePacketPtr, & uResponseLength);

						if (iStatus == XST_SUCCESS)
						{
							// Create rest of Ethernet packet in transmit buffer for response
							CreateResponsePacket(uId, (u8 *) uTransmitBuffer, uResponseLength);
							* uResponsePacketLengthBytes = (uResponseLength + sizeof(sEthernetHeaderT) + sizeof(sIPV4HeaderT) + sizeof(sUDPHeaderT));

							return XST_SUCCESS;
						}
						else
							return XST_FAILURE;

					}
					else if (uUdpDstPort == DHCP_CLIENT_UDP_PORT)
					{
						iStatus = CheckDHCPHeader(uId, uL5PktLen, pL5Ptr);

						if (iStatus == XST_SUCCESS)
						{
#ifdef DEBUG_PRINT
							xil_printf("DHCP packet received!\r\n");
#endif
							// iStatus = DHCPHandler(uId, pL5Ptr, uL5PktLen, (u8 *) uTransmitBuffer, uResponsePacketLengthBytes);

							return iStatus;
						}
						else
							return XST_FAILURE;
					}
					else
						return XST_FAILURE;

				}
				else
					return XST_FAILURE;
			}
			else
				return XST_FAILURE;
		}
		else
			return XST_FAILURE;
	}
	else
		return XST_FAILURE;

}

//=================================================================================
//	ArpRequestHandler
//--------------------------------------------------------------------------------
//	This method constucts ARP requests to populate the ARP caches in the fabric
//	Ethernet interfaces.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void ArpRequestHandler()
{
	u32 uCurrentArpRequestIPAddress;
	u32 uResponseLength;

	uUpdateArpRequests = ARP_REQUEST_DONT_UPDATE;

	if (uEnableArpRequests[uCurrentArpEthernetInterface] == ARP_REQUESTS_ENABLE)
	{
	   	// Create an ARP request
	    uCurrentArpRequestIPAddress = uEthernetSubnet[uCurrentArpEthernetInterface] | uCurrentArpRequest;
	    ArpHandler(uCurrentArpEthernetInterface, ARP_REQUEST, (u8*) uReceiveBuffer, (u8*) uTransmitBuffer, & uResponseLength, uCurrentArpRequestIPAddress);
	   	uResponseLength = (uResponseLength >> 2);
	    TransmitHostPacket(uCurrentArpEthernetInterface, & uTransmitBuffer[0], uResponseLength);
	}

    if (uCurrentArpRequest == 254)
    {
		uCurrentArpRequest = 1;

		if ((uCurrentArpEthernetInterface + 1) == NUM_ETHERNET_INTERFACES)
    		uCurrentArpEthernetInterface = 0;
    	else
    		uCurrentArpEthernetInterface++;
    }
    else
    	uCurrentArpRequest++;
}

//=================================================================================
//	UpdateEthernetLinkUpStatus
//--------------------------------------------------------------------------------
//	This method updates the Ethernet link up status. The Ethernet interface is not
//	checked for received messages if it is not up. When the Ethernet link comes up,
//	the ARP packet requests are enabled to populate the ARP cache.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	uId			IN		ID of selected Ethernet interface
//
//	Return
//	------
//	None
//=================================================================================
void UpdateEthernetLinkUpStatus(u8 uId)
{
	u32 uReg = ReadBoardRegister(C_RD_ETH_IF_LINK_UP_ADDR);

	if ((uReg & (0x1 << uId)) != LINK_DOWN)
	{
		// Check if the link was down
		if (uEthernetLinkUp[uId] == LINK_DOWN)
		{
			xil_printf("LINK %x HAS COME UP!\r\n",uId);
		}

		if ((uEthernetLinkUp[uId] == LINK_DOWN)&&(uId == 0))
		{
			// Put DHCP into DISCOVER STATE
#ifndef DO_1GBE_LOOPBACK_TEST
			uDHCPState[uId] = DHCP_STATE_DISCOVER;
			//uDHCPRetryTimer[uId] = DHCP_RETRY_ENABLED;
      vDHCPStateMachineReset(&DHCPContextState[uId]);
      uDHCPSetStateMachineEnable(&DHCPContextState[uId], SM_TRUE);
#endif
		}

		if ((uEthernetLinkUp[uId] == LINK_DOWN)&&(uId != 0))
		{
			// Put DHCP into DISCOVER STATE
#ifndef DO_40GBE_LOOPBACK_TEST
			uDHCPState[uId] = DHCP_STATE_DISCOVER;
			//uDHCPRetryTimer[uId] = DHCP_RETRY_ENABLED;
      vDHCPStateMachineReset(&DHCPContextState[uId]);
      uDHCPSetStateMachineEnable(&DHCPContextState[uId], SM_TRUE);
#endif

			/*if ((uEthernetNeedsReset[uId] == NEEDS_RESET)||(uEthernetNeedsReset[uId] == LINK_DOWN_RESET_DONE))
			{
				uReg = (0x1 << uId);
				uQSFPCtrlReg = uQSFPCtrlReg | uReg;
				xil_printf("RESETTING LINK %x!\r\n",uId);
				WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
				Delay(1);
				uQSFPCtrlReg = uQSFPCtrlReg & (~ uReg);
				WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
				uEthernetNeedsReset[uId] = RESET_DONE;
			}*/

		}

		uEthernetLinkUp[uId] = LINK_UP;
	}
	else
	{
		// Check if the link was up
		if (uEthernetLinkUp[uId] == LINK_UP)
		{
			xil_printf("LINK %x HAS GONE DOWN!\r\n",uId);
		}

		if ((uEthernetLinkUp[uId] == LINK_UP)&&(uId == 0))
		{
			// Put DHCP into IDLE STATE
#ifndef DO_1GBE_LOOPBACK_TEST
			uDHCPState[uId] = DHCP_STATE_IDLE;
			uEthernetFabricIPAddress[uId] = 0;
			uEthernetGatewayIPAddress[uId] = 0;
			uEthernetSubnet[uId] = 0;
#endif
		}

		if ((uEthernetLinkUp[uId] == LINK_UP)&&(uId != 0))
		{
			// Put DHCP into IDLE STATE
#ifndef DO_40GBE_LOOPBACK_TEST
			uDHCPState[uId] = DHCP_STATE_IDLE;
			uEthernetFabricIPAddress[uId] = 0;
			uEthernetGatewayIPAddress[uId] = 0;
			uEthernetSubnet[uId] = 0;
#endif
		}

		/*if ((uEthernetNeedsReset[uId] == NEEDS_RESET)&&(uId != 0))
		{
			uReg = (0x1 << uId);
			uQSFPCtrlReg = uQSFPCtrlReg | uReg;
			xil_printf("RESETTING LINK %x!\r\n",uId);
			WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
			Delay(1);
			uQSFPCtrlReg = uQSFPCtrlReg & (~ uReg);
			WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
			uEthernetNeedsReset[uId] = LINK_DOWN_RESET_DONE;
		}*/

		uEthernetLinkUp[uId] = LINK_DOWN;
		uEnableArpRequests[uId] = ARP_REQUESTS_DISABLE;

		uIGMPState[uId] = IGMP_STATE_NOT_JOINED;
	}
}

//=================================================================================
//	UpdateQSFPStatus
//--------------------------------------------------------------------------------
//	This method updates the status of modules present and LEDs.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void UpdateQSFPStatus()
{
	u16 uWriteBytes[7];
	u16 uReadBytes[3];
	int iStatus = XST_SUCCESS;
	u32 uReg;
	u8 uId = 0x0;
	u32 uLedTxReg = 0x0;
	u32 uLedRxReg = 0x0;
	u32 uLinkMask = 0x10000;
	u32 uActivityMask = 0x20000;

	if ((uPxSerialNumber == 93121)&&(uQSFPMezzanineLocation == 1))
	{
		// ONE OF THE PROTOTYPE SYSTEMS HAS A PROBLEM WITH I2C ON MEZZANINE SITE 1
		// BRING ALL CHANNELS OUT OF RESET
		// DON'T TRY TO ACCESS I2C
		uQSFPCtrlReg = 0x0;
		WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
	}
	else
	{
		if (uQSFPUpdateStatusEnable == UPDATE_QSFP_STATUS)
		{
			uQSFPUpdateStatusEnable = DO_NOT_UPDATE_QSFP_STATUS;

			if (uQSFPState == QSFP_STATE_BOOTLOADER_VERSION_WRITE_MODE)
			{
				// Need to read and store QSFP+ bootloader version before exit bootloader mode
				uWriteBytes[0] = QSFP_BOOTLOADER_READ_OPCODE;
				uWriteBytes[1] = ((QSFP_BOOTLOADER_VERSION_ADDRESS >> 24) & 0xFF);
				uWriteBytes[2] = ((QSFP_BOOTLOADER_VERSION_ADDRESS >> 16) & 0xFF);
				uWriteBytes[3] = ((QSFP_BOOTLOADER_VERSION_ADDRESS >> 8) & 0xFF);
				uWriteBytes[4] = (QSFP_BOOTLOADER_VERSION_ADDRESS & 0xFF);
				uWriteBytes[5] = 0x01; // Reading 1 byte
				//xil_printf("QSFP+ Mezzanine writing version address.\r\n");

				iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_BOOTLOADER_SLAVE_ADDRESS, uWriteBytes, 6);

				if (iStatus != XST_SUCCESS)
					xil_printf("BOOTLOADER I2C WRITE FAILED\r\n");

				uQSFPState = QSFP_STATE_BOOTLOADER_VERSION_READ_MODE;
			}
			else if (uQSFPState == QSFP_STATE_BOOTLOADER_VERSION_READ_MODE)
			{
				//xil_printf("QSFP+ Mezzanine reading bootloader version.\r\n");

				iStatus = ReadI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_BOOTLOADER_SLAVE_ADDRESS, uReadBytes, 1);

				if (iStatus != XST_SUCCESS)
					xil_printf("BOOTLOADER I2C READ FAILED\r\n");

				uQSFPBootloaderVersionMajor = (uReadBytes[0] >> 4) & 0xF;
				uQSFPBootloaderVersionMinor = uReadBytes[0] & 0xF;

				xil_printf("QSFP+ Mezzanine bootloader version: %x.%x\r\n", uQSFPBootloaderVersionMajor, uQSFPBootloaderVersionMinor);

				uQSFPState = QSFP_STATE_INITIAL_BOOTLOADER_MODE;
			}
			else if(uQSFPState == QSFP_STATE_INITIAL_BOOTLOADER_MODE)
			{
				uWriteBytes[0] = QSFP_LEAVE_BOOTLOADER_MODE;
				xil_printf("QSFP+ Mezzanine leaving bootloader mode.\r\n");

				iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_BOOTLOADER_SLAVE_ADDRESS, uWriteBytes, 1);

				if (iStatus != XST_SUCCESS)
					xil_printf("BOOTLOADER I2C WRITE FAILED\r\n");

				uQSFPState = QSFP_STATE_STARTING_APPLICATION_MODE;
				//uQSFPStateCounter = 0;
			}
			else if (uQSFPState == QSFP_STATE_APPLICATION_MODE)
			{
				if (uQSFPI2CMicroblazeAccess == QSFP_I2C_MICROBLAZE_ENABLE)
				{
					if (uQSFPUpdateState == QSFP_UPDATING_TX_LEDS)
					{
						uQSFPUpdateState = QSFP_UPDATING_RX_LEDS;

						uReg = ReadBoardRegister(C_RD_ETH_IF_LINK_UP_ADDR);
						//xil_printf("uReg: %x\r\n", uReg);

#ifdef SKARAB_BSP
						for (uId = 0x0; uId < 0x4; uId++)
#else
						for (uId = 0x0; uId < (NUM_ETHERNET_INTERFACES - 1); uId++)
#endif
						{
							// Check TX link
							if ((uReg & uLinkMask) != 0x0)
							{
								// Check if activity as well
								if ((uReg & uActivityMask) != 0x0)
									uLedTxReg = uLedTxReg | (LED_FLASHING << (uId * 2));
								else
									uLedTxReg = uLedTxReg | (LED_ON << (uId * 2));
							}
							else
								uLedTxReg = uLedTxReg | (LED_OFF << (uId * 2));

							uLinkMask = uLinkMask << 2;
							uActivityMask = uActivityMask << 2;

							// Check RX link
							if ((uReg & uLinkMask) != 0x0)
							{
								// Check if activity as well
								if ((uReg & uActivityMask) != 0x0)
									uLedRxReg = uLedRxReg | (LED_FLASHING << (uId * 2));
								else
									uLedRxReg = uLedRxReg | (LED_ON << (uId * 2));
							}
							else
								uLedRxReg = uLedRxReg | (LED_OFF << (uId * 2));

							uLinkMask = uLinkMask << 2;
							uActivityMask = uActivityMask << 2;
						}

						// GT 04/06/2015 CHANGE TO ALWAYS WRITE if (uLedTxReg != uQSFPMezzanineCurrentTxLed)
						//{
							uWriteBytes[0] = QSFP_LED_TX_REG_ADDRESS;
							uWriteBytes[1] = uLedTxReg;
							iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uWriteBytes, 2);

							if (iStatus != XST_SUCCESS)
								xil_printf("TX LED MEZ I2C WRITE FAILED\r\n");

							//xil_printf("uLedTxReg: %x\r\n", uLedTxReg);
							uQSFPMezzanineCurrentTxLed = uLedTxReg;
						//}
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_RX_LEDS)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_0_WRITE;

						uReg = ReadBoardRegister(C_RD_ETH_IF_LINK_UP_ADDR);

#ifdef SKARAB_BSP
						for (uId = 0x0; uId < 0x4; uId++)
#else
						for (uId = 0x0; uId < (NUM_ETHERNET_INTERFACES - 1); uId++)
#endif
						{
							// Check TX link
							if ((uReg & uLinkMask) != 0x0)
							{
								// Check if activity as well
								if ((uReg & uActivityMask) != 0x0)
									uLedTxReg = uLedTxReg | (LED_FLASHING << (uId * 2));
								else
									uLedTxReg = uLedTxReg | (LED_ON << (uId * 2));
							}
							else
								uLedTxReg = uLedTxReg | (LED_OFF << (uId * 2));

							uLinkMask = uLinkMask << 2;
							uActivityMask = uActivityMask << 2;

							// Check RX link
							if ((uReg & uLinkMask) != 0x0)
							{
								// Check if activity as well
								if ((uReg & uActivityMask) != 0x0)
									uLedRxReg = uLedRxReg | (LED_FLASHING << (uId * 2));
								else
									uLedRxReg = uLedRxReg | (LED_ON << (uId * 2));
							}
							else
								uLedRxReg = uLedRxReg | (LED_OFF << (uId * 2));

							uLinkMask = uLinkMask << 2;
							uActivityMask = uActivityMask << 2;
						}

						// GT 04/06/2015 CHANGE TO ALWAYS WRITE if (uLedRxReg != uQSFPMezzanineCurrentRxLed)
						//{
							uWriteBytes[0] = QSFP_LED_RX_REG_ADDRESS;
							uWriteBytes[1] = uLedRxReg;
							iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uWriteBytes, 2);

							if (iStatus != XST_SUCCESS)
								xil_printf("RX LED MEZ I2C WRITE FAILED\r\n");

							//xil_printf("uLedRxReg: %x\r\n", uLedRxReg);
							uQSFPMezzanineCurrentRxLed = uLedRxReg;
						//}
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_0_WRITE)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_0_READ;

						uWriteBytes[0] = QSFP_MODULE_0_PRESENT_REG_ADDRESS;
						iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uWriteBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 0 MEZ I2C WRITE FAILED\r\n");
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_0_READ)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_1_WRITE;

						iStatus = ReadI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uReadBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 0 MEZ I2C READ FAILED\r\n");

						if (uReadBytes[0] != 0x0)
							// If a module is present, take out of reset
							uQSFPCtrlReg = uQSFPCtrlReg & (~ QSFP0_RESET);
						else
							// If a module is not present, put in reset
							uQSFPCtrlReg = uQSFPCtrlReg | QSFP0_RESET;

						WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_1_WRITE)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_1_READ;

						uWriteBytes[0] = QSFP_MODULE_1_PRESENT_REG_ADDRESS;
						iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uWriteBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 1 MEZ I2C WRITE FAILED\r\n");
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_1_READ)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_2_WRITE;

						iStatus = ReadI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uReadBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 1 MEZ I2C READ FAILED\r\n");

						if (uReadBytes[0] != 0x0)
							// If a module is present, take out of reset
							uQSFPCtrlReg = uQSFPCtrlReg & (~ QSFP1_RESET);
						else
							// If a module is not present, put in reset
							uQSFPCtrlReg = uQSFPCtrlReg | QSFP1_RESET;

						WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_2_WRITE)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_2_READ;

						uWriteBytes[0] = QSFP_MODULE_2_PRESENT_REG_ADDRESS;
						iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uWriteBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 2 MEZ I2C WRITE FAILED\r\n");
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_2_READ)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_3_WRITE;

						iStatus = ReadI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uReadBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 2 MEZ I2C READ FAILED\r\n");

						if (uReadBytes[0] != 0x0)
							// If a module is present, take out of reset
							uQSFPCtrlReg = uQSFPCtrlReg & (~ QSFP2_RESET);
						else
							// If a module is not present, put in reset
							uQSFPCtrlReg = uQSFPCtrlReg | QSFP2_RESET;

						WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_3_WRITE)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_3_READ;

						uWriteBytes[0] = QSFP_MODULE_3_PRESENT_REG_ADDRESS;
						iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uWriteBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 3 MEZ I2C WRITE FAILED\r\n");
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_3_READ)
					{
						uQSFPUpdateState = QSFP_UPDATING_TX_LEDS;

						iStatus = ReadI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uReadBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 3 MEZ I2C READ FAILED\r\n");

						if (uReadBytes[0] != 0x0)
							// If a module is present, take out of reset
							uQSFPCtrlReg = uQSFPCtrlReg & (~ QSFP3_RESET);
						else
							// If a module is not present, put in reset
							uQSFPCtrlReg = uQSFPCtrlReg | QSFP3_RESET;

						WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
					}
				}
			}
		}
	}
}

//=================================================================================
//	InitialiseEthernetInterfaceParameters
//--------------------------------------------------------------------------------
//	This method configures the Ethernet interfaces with some default values.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void InitialiseEthernetInterfaceParameters()
{
	u8 uId;
	u16 uRom[8];
	u16 uSerial[4];
	u16 uFabricMacHigh;
	u16 uFabricMacMid;
	u16 uFabricMacLow;
	u16 uPxSerial[3];
	int iSuccess;
	u16 uRomCRC;

	uCurrentArpEthernetInterface = 0;
	uCurrentArpRequest = 1;
	uUpdateArpRequests = ARP_REQUEST_DONT_UPDATE;
	uDHCPCompleteSetLeds = FALSE;
	uPreviousAsyncSdramRead = 0;
	uPreviousSequenceNumber = 0;

	iSuccess = OneWireReadRom(uRom, MB_ONE_WIRE_PORT);

	if (iSuccess == XST_SUCCESS)
	{
		// GT 05/06/2015 CHECK CRC OF ROM TO CONFIRM OK
		uRomCRC = OneWireCrc8(& uRom[0], 0x7);
		if (uRomCRC != uRom[7])
		{
			xil_printf("MB 1-wire CRC incorrect.\r\n");
			uSerial[0] = 0xFF;
			uSerial[1] = 0xFF;
			uSerial[2] = 0xFF;
			uSerial[3] = 0xFF;
		}
		else
		{
			// Read the serial number
			iSuccess = DS2433ReadMem(uRom, 0, uSerial, 4, 0, 0, MB_ONE_WIRE_PORT);

			if (iSuccess == XST_FAILURE)
			{
				xil_printf("Failed to read serial number.\r\n");
				uSerial[0] = 0xFF;
				uSerial[1] = 0xFF;
				uSerial[2] = 0xFF;
				uSerial[3] = 0xFF;
			}
		}
	}
	else
	{
		xil_printf("Failed to read serial number.\r\n");
		uSerial[0] = 0xFF;
		uSerial[1] = 0xFF;
		uSerial[2] = 0xFF;
		uSerial[3] = 0xFF;
	}

	// GT 04/06/2015 BASIC SANITY CHECK, IF FAILS TRY TO READ ONE MORE TIME
	if (uSerial[0] != 0x50) // CHECK FOR 'P'
	{
		xil_printf("Trying again to read serial number.\r\n");

		iSuccess = OneWireReadRom(uRom, MB_ONE_WIRE_PORT);

		if (iSuccess == XST_SUCCESS)
		{
			// GT 05/06/2015 CHECK CRC OF ROM TO CONFIRM OK
			uRomCRC = OneWireCrc8(& uRom[0], 0x7);
			if (uRomCRC != uRom[7])
			{
				xil_printf("MB 1-wire CRC incorrect.\r\n");
				uSerial[0] = 0xFF;
				uSerial[1] = 0xFF;
				uSerial[2] = 0xFF;
				uSerial[3] = 0xFF;
			}
			else
			{
				// Read the serial number
				iSuccess = DS2433ReadMem(uRom, 0, uSerial, 4, 0, 0, MB_ONE_WIRE_PORT);

				if (iSuccess == XST_FAILURE)
				{
					xil_printf("Failed to read serial number.\r\n");
					uSerial[0] = 0xFF;
					uSerial[1] = 0xFF;
					uSerial[2] = 0xFF;
					uSerial[3] = 0xFF;
				}
			}
		}
		else
		{
			xil_printf("Failed to read serial number.\r\n");
			uSerial[0] = 0xFF;
			uSerial[1] = 0xFF;
			uSerial[2] = 0xFF;
			uSerial[3] = 0xFF;
		}
	}

	// TO DO: NOT SURE WHAT TO DO HERE FOR MULTICAST
	uFabricMacHigh = 0x0600 | uSerial[0];
	uFabricMacMid = (uSerial[1] << 8) | uSerial[2];

	for (uId = 0; uId < NUM_ETHERNET_INTERFACES; uId++)
	{
		uEnableArpRequests[uId] = ARP_REQUESTS_DISABLE;
		uEthernetLinkUp[uId] = LINK_DOWN;
		uEthernetFabricSubnetMask[uId] = ETHERNET_FABRIC_SUBNET_MASK;
		uEthernetFabricPortAddress[uId] = ETHERNET_FABRIC_PORT_ADDRESS;
		uEthernetSubnet[uId] = ETHERNET_FABRIC_SUBNET;
		uIPIdentification[uId] = 0x7342;

#ifdef DO_40GBE_LOOPBACK_TEST
		xil_printf("Setting all 40GBE MAC addresses same so can test in loopback!\r\n");
		if (uId == 0)
			uFabricMacLow = (uSerial[3] << 8) | uId;
		else
			uFabricMacLow = (uSerial[3] << 8) | 0x1;
#else
		uFabricMacLow = (uSerial[3] << 8) | uId;
#endif

		uEthernetFabricMacHigh[uId] = uFabricMacHigh;
		uEthernetFabricMacMid[uId] = uFabricMacMid;
		uEthernetFabricMacLow[uId] = uFabricMacLow;

		xil_printf("Setting MAC for IF %x TO %x %x %x\r\n", uId, uFabricMacHigh, uFabricMacMid, uFabricMacLow);
		SetFabricSourceMACAddress(uId, uEthernetFabricMacHigh[uId], ((uEthernetFabricMacMid[uId] << 16) | (uEthernetFabricMacLow[uId])));
		//SetFabricSourcePortAddress(uId, uEthernetFabricPortAddress[uId]);

		uDHCPTransactionID[uId] = uId;
		uDHCPState[uId] = DHCP_STATE_IDLE;
		//uDHCPRetryTimer[uId] = DHCP_RETRY_ENABLED;

		uIGMPState[uId] = IGMP_STATE_NOT_JOINED;
		uIGMPSendMessage[uId] = IGMP_SEND_MESSAGE;
		uCurrentIGMPMessage[uId] = 0x0;

		uEthernetNeedsReset[uId] = NEEDS_RESET;

		iSuccess = SoftReset(uId);

#ifdef DEBUG_PRINT
		if (iSuccess == XST_FAILURE)
			xil_printf("ID: %x Failed to do soft reset\r\n", uId);
		else
		    xil_printf("ID: %x Soft reset successful.\r\n", uId);
#endif

	}

	// PERALEX SERIAL NUMBER
	iSuccess = DS2433ReadMem(uRom, 0, uPxSerial, 3, 7, 0, MB_ONE_WIRE_PORT);

	if (iSuccess == XST_FAILURE)
	{
		xil_printf("Failed to read Px serial number.\r\n");
		uPxSerial[0] = 0xFF;
		uPxSerial[1] = 0xFF;
		uPxSerial[2] = 0xFF;
	}

	uPxSerialNumber = uPxSerial[2] + (uPxSerial[1] << 8) + (uPxSerial[0] << 16);
#ifdef DEBUG_PRINT
	xil_printf("Motherboard Px Serial Number: %d\r\n", uPxSerialNumber);
#endif

}

//=================================================================================
//	InitialiseEthernetInterfaceParameters
//--------------------------------------------------------------------------------
//	This method configures the Ethernet interfaces with some default values.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void InitialiseQSFPMezzanineLocation()
{
	u32 uReg;
	u32 uMezzanineMask;
	u16 uDeviceRom[8];
	u16 uReadBytes[32];
	int iStatus = XST_SUCCESS;
	u16 uOneWirePort;

	uQSFPMezzanineLocation = 0x0;
	uQSFPMezzaninePresent = QSFP_MEZZANINE_NOT_PRESENT;
	uQSFPMezzanineCurrentTxLed = 0x0;
	uQSFPMezzanineCurrentRxLed = 0x0;
	uQSFPUpdateState = QSFP_UPDATING_TX_LEDS;
	uQSFPUpdateStatusEnable = DO_NOT_UPDATE_QSFP_STATUS;
	uQSFPI2CMicroblazeAccess = QSFP_I2C_MICROBLAZE_ENABLE;
	uQSFPStateCounter = 0;
	uQSFPState = QSFP_STATE_RESET;

	uQSFPCtrlReg = QSFP0_RESET | QSFP1_RESET | QSFP2_RESET | QSFP3_RESET;
	WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);

	uReg = ReadBoardRegister(C_RD_MEZZANINE_STAT_ADDR);

	while ((uQSFPMezzaninePresent == QSFP_MEZZANINE_NOT_PRESENT)&&(uQSFPMezzanineLocation < 0x4))
	{
		uMezzanineMask = 0x1 << uQSFPMezzanineLocation;
		uOneWirePort = uQSFPMezzanineLocation + 0x1;

		// Check if a mezzanine is preset
		if ((uReg & uMezzanineMask) != 0x0)
		{
			// Mezzanine present here, read manufacturer code in 1-wire to see if Peralex board
			iStatus = OneWireReadRom(uDeviceRom, uOneWirePort);

			if (iStatus == XST_SUCCESS)
			{
				iStatus = DS2433ReadMem(uDeviceRom, 0x0, uReadBytes, 0x1, 0x0, 0x0, uOneWirePort);

				if ((iStatus == XST_SUCCESS)&&(uReadBytes[0] == 0x50)) // Check if read 'P'
				{
					xil_printf("Mezzanine %x is a QSFP+ MEZZANINE\r\n", uQSFPMezzanineLocation);
					uQSFPMezzaninePresent = QSFP_MEZZANINE_PRESENT;
				}
				else
				{
					uQSFPMezzanineLocation++;
				}
			}
			else
			{
				uQSFPMezzanineLocation++;
			}
		}
		else
		{
			uQSFPMezzanineLocation++;
		}

	}

	if (uQSFPMezzaninePresent == QSFP_MEZZANINE_NOT_PRESENT)
		xil_printf("Failed to find a QSFP+ MEZZANINE!\r\n");
}

//=================================================================================
//	InitialiseInterruptControllerAndTimer
//--------------------------------------------------------------------------------
//	This method configures the interrupt controller and timer used for DHCP timeouts.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void InitialiseInterruptControllerAndTimer(XTmrCtr * pTimer, XIntc * pInterruptController)
{
	u32 uDHCPTimerOptions;
	int iStatus;

	iStatus = XTmrCtr_Initialize(pTimer, XPAR_TMRCTR_0_DEVICE_ID);

	if (iStatus != XST_SUCCESS)
	   xil_printf("Failed to initialise DHCP retry timer.\r\n");

	iStatus = XIntc_Initialize(pInterruptController, XPAR_INTC_SINGLE_DEVICE_ID);

	if (iStatus == XST_DEVICE_IS_STARTED)
	{
	   XIntc_Stop(pInterruptController);
	   iStatus = XIntc_Initialize(pInterruptController, XPAR_INTC_SINGLE_DEVICE_ID);
	}

	if (iStatus == XST_SUCCESS)
	{
	   iStatus = XIntc_Connect(pInterruptController, XPAR_INTC_0_TMRCTR_0_VEC_ID, (XInterruptHandler) XTmrCtr_InterruptHandler, (void*) pTimer);

	   if (iStatus == XST_SUCCESS)
	   {
		   iStatus =  XIntc_Start(pInterruptController, XIN_REAL_MODE);
		   if (iStatus == XST_SUCCESS)
			   XIntc_Enable(pInterruptController, XPAR_INTC_0_TMRCTR_0_VEC_ID);
		   else
			   xil_printf("Failed to start interrupt controller.\r\n");
	   }
	   else
		   xil_printf("Failed to connect Timer interrupt to interrupt controller.\r\n");
	}
	else
	   xil_printf("Failed to initialise interrupt controller.\r\n");

	microblaze_enable_interrupts();

	XTmrCtr_SetHandler(pTimer, TimerHandler, pTimer);
	uDHCPTimerOptions = XTC_INT_MODE_OPTION | XTC_AUTO_RELOAD_OPTION | XTC_DOWN_COUNT_OPTION;
	XTmrCtr_SetOptions(pTimer, DHCP_RETRY_TIMER_ID, uDHCPTimerOptions);
	XTmrCtr_SetResetValue(pTimer, DHCP_RETRY_TIMER_ID, DHCP_TIMER_RESET_VALUE);
	XTmrCtr_Start(pTimer, DHCP_RETRY_TIMER_ID);

	uIGMPTimerCounter = 0;
	uIGMPTimerCounter = 0;
}

//=================================================================================
//	ReadAndPrintFPGADNA
//--------------------------------------------------------------------------------
//	This method reads and prints out the FPGA DNA value.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void ReadAndPrintFPGADNA()
{
	u32 uDNALow = ReadBoardRegister(C_RD_FPGA_DNA_LOW_ADDR);
	u32 uDNAHigh = ReadBoardRegister(C_RD_FPGA_DNA_HIGH_ADDR);
	u8 uBitShift = 28;
	u8 uNibbleCount;
	u32 uNibble;

	// Print out each nibble in hex format
	xil_printf("FPGA DNA: 0x");

	for (uNibbleCount = 0; uNibbleCount < 8; uNibbleCount++)
	{
		uNibble = (uDNAHigh >> uBitShift) & 0xF;
		xil_printf("%x", uNibble);
		if (uBitShift > 0)
			uBitShift = uBitShift - 4;
	}

	uBitShift = 28;

	for (uNibbleCount = 0; uNibbleCount < 8; uNibbleCount++)
	{
		uNibble = (uDNALow >> uBitShift) & 0xF;
		xil_printf("%x", uNibble);
		if (uBitShift > 0)
			uBitShift = uBitShift - 4;
	}

	xil_printf("\r\n");
}


int main() 
{
	   int iStatus;
	   u32 uReadReg;
#ifdef DEV_PLATFORM
	   u32 uSleepCount;
#endif
	   u8 uEthernetId;
	   u32 uNumWords;
	   u32 uDHCPOptionsLength;
	   u32 uResponsePacketLength;
	   XTmrCtr Timer;
	   XIntc InterruptController;
	   XWdtTb WatchdogTimer;
	   u32 uIGMPGroupAddress;
	   u8 uOKToReboot;
#ifdef DO_40GBE_LOOPBACK_TEST
	   u32 uTemp40GBEIPAddress = 0x0A000802;
	   u8 uConfig40GBE[4];
	   uConfig40GBE[0] = 0x1;
	   uConfig40GBE[1] = 0x1;
	   uConfig40GBE[2] = 0x1;
	   uConfig40GBE[3] = 0x1;
#endif

#ifdef DO_1GBE_LOOPBACK_TEST
	   u32 uTemp1GBEIPAddress = 0x0A000702;
	   u8 uConfig1GBE = 0x1;
#endif

     //struct sDHCPObject DHCPContextState[NUM_ETHERNET_INTERFACES];  /* TODO do we have enough stack space???*/
     u8 arrEthId[NUM_ETHERNET_INTERFACES];
     u8 uTempMac[6];
#ifdef DEBUG_PRINT
     u16 uCountDumpStats_DHCP=0;
#endif

	   Xil_ICacheEnable();
	   Xil_DCacheEnable();

	   uFrontPanelTimerCounter = 0x0;
	   uFrontPanelLeds = LED_OFF;

	   uDoReboot = NO_REBOOT;

	   InitI2C(0x0, SPEED_100kHz);
	   InitI2C(0x1, SPEED_400kHz);
	   InitI2C(0x2, SPEED_400kHz);
	   InitI2C(0x3, SPEED_400kHz);
	   InitI2C(0x4, SPEED_400kHz);

#ifdef DEV_PLATFORM
	   iStatus = I2CProgramRefClkOsc();
	   if (iStatus == 0)
	   {
		   xil_printf("Programming Refclk OSC success\r\n");
	   }
	   else
	   {
		   xil_printf("Programming Refclk OSC failed\r\n");
	   }
#endif

	   xil_printf("---Entering main---\n\r");

#ifdef DEV_PLATFORM
	   iStatus = I2CProgramSFPClkOsc();
	   if (iStatus == 0)
	   {
		   xil_printf("Programming SFP OSC success\r\n");
	   }
	   else
	   {
		   xil_printf("Programming SFP OSC failed\r\n");
	   }

	   // Sleep for five seconds because this is a dangerous time for the
	   // system clock
	   for (uSleepCount = 0; uSleepCount < 5000; uSleepCount++)
		   Delay(1000);
#endif

	   // Enable the watchdog timer
	   xil_printf("Initialising the WDT.\r\n");

	   iStatus = XWdtTb_Initialize(& WatchdogTimer, XPAR_WDTTB_0_DEVICE_ID);

	   if (iStatus == XST_DEVICE_IS_STARTED)
	   {
		   XWdtTb_Stop(& WatchdogTimer);

		   iStatus = XWdtTb_Initialize(& WatchdogTimer, XPAR_WDTTB_0_DEVICE_ID);
	   }

	   if (iStatus == XST_SUCCESS)
	   {
		   if (XWdtTb_IsWdtExpired(& WatchdogTimer))
			   xil_printf("Previous reset result of WDT.\r\n");

		   XWdtTb_Start(& WatchdogTimer);
	   }
	   else
		   xil_printf("Failed to initialise the WDT.\r\n");

	   FinishedBootingFromSdram();

	   xil_printf("Waiting for 1GBE SGMII to come out of reset...\r\n");

	   do
	   {
		   uReadReg = ReadBoardRegister(C_RD_BRD_CTL_STAT_0_ADDR);
	   }while((uReadReg & 0x1) != 0x1);

	   InitialiseInterruptControllerAndTimer(& Timer, & InterruptController);

	   InitialiseQSFPMezzanineLocation();

	   InitialiseEthernetInterfaceParameters();

	   iStatus = XST_SUCCESS;

	   ReadAndPrintFPGADNA();

     /* DHCP State initializations for each interface */
     /* TODO: perhaps create an inline function for the following to neaten up code */
     /* the first 5 octets of the mac address /should/ never change across interfaces */
     uTempMac[0] = (uEthernetFabricMacHigh[0] >> 8) & 0xff;
     uTempMac[1] = (uEthernetFabricMacHigh[0]     ) & 0xff;
     uTempMac[2] = (uEthernetFabricMacMid[0]  >> 8) & 0xff;
     uTempMac[3] = (uEthernetFabricMacMid[0]      ) & 0xff;
     uTempMac[4] = (uEthernetFabricMacLow[0]  >> 8) & 0xff;

     u8 uTempHostNameString[16] = "skarab";   /* 15 chars plus '/0'. To be appended just now with partial mac & i/f. */
     u8 uTempDigit;

     /* stringify mac and append to hostname ("skarab" - see initialization above ) */

     uTempDigit = ((uEthernetFabricMacMid[0] >> 8) & 0xff) / 0x10;  /* upper digit of upper octet of mac-mid */
     uTempHostNameString[6] = uTempDigit > 9 ? ((uTempDigit - 10) + 0x41) : (uTempDigit + 0x30);

     uTempDigit = ((uEthernetFabricMacMid[0] >> 8) & 0xff) % 0x10;  /* lower digit of upper octet of mac-mid */
     uTempHostNameString[7] = uTempDigit > 9 ? ((uTempDigit - 10) + 0x41) : (uTempDigit + 0x30);

     uTempDigit = ((uEthernetFabricMacMid[0]) & 0xff) / 0x10;  /* upper digit of lower octet of mac-mid */
     uTempHostNameString[8] = uTempDigit > 9 ? ((uTempDigit - 10) + 0x41) : (uTempDigit + 0x30);

     uTempDigit = ((uEthernetFabricMacMid[0]) & 0xff) % 0x10;  /* lower digit of lower octet of mac-mid */
     uTempHostNameString[9] = uTempDigit > 9 ? ((uTempDigit - 10) + 0x41) : (uTempDigit + 0x30);

     uTempDigit = ((uEthernetFabricMacLow[0] >> 8) & 0xff) / 0x10;  /* upper digit of upper octet of mac-low */
     uTempHostNameString[10] = uTempDigit > 9 ? ((uTempDigit - 10) + 0x41) : (uTempDigit + 0x30);

     uTempDigit = ((uEthernetFabricMacLow[0] >> 8) & 0xff) % 0x10;  /* lower digit of upper octet of mac-low */
     uTempHostNameString[11] = uTempDigit > 9 ? ((uTempDigit - 10) + 0x41) : (uTempDigit + 0x30);


     uTempHostNameString[12] = '-';

     for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++){
       arrEthId[uEthernetId] = uEthernetId;
       
       /* 6th octet of mac should equal id anyway */
       uTempMac[5] = uEthernetFabricMacLow[uEthernetId] & 0xff;
       /* fill in interface number in host name and terminate string */
       uTempHostNameString[13] = (uEthernetId / 10) + 48;  /* tens digit of interface id*/
       uTempHostNameString[14] = (uEthernetId % 10) + 48;  /* unit digit of interface id*/
       uTempHostNameString[15] = '\0';  /* unit digit of interface id*/

       uDHCPInit(&DHCPContextState[uEthernetId], (u8 *) uReceiveBuffer, (256 * 4), uTransmitBuffer, (256 * 4), uTempMac);
       eventDHCPOnMsgBuilt(&DHCPContextState[uEthernetId], &vSendDHCPMsg, &arrEthId[uEthernetId]);
       eventDHCPOnLeaseAcqd(&DHCPContextState[uEthernetId], &vSetInterfaceConfig, &arrEthId[uEthernetId]);
       vDHCPSetHostName(&DHCPContextState[uEthernetId], (char *) &uTempHostNameString);
       uDHCPSetStateMachineEnable(&DHCPContextState[uEthernetId], TRUE);
     }

	   while(1)
	   {
		   if (uQSFPMezzaninePresent == QSFP_MEZZANINE_PRESENT)
			   UpdateQSFPStatus();

			if (uUpdateArpRequests == ARP_REQUEST_UPDATE)
			   ArpRequestHandler();

      /* simple interrupt driven multi-tasking scheduler */

      /* is it time... */
      /* ... to run the dhcp task */
      if (uFlagRunTask_DHCP){
        uFlagRunTask_DHCP = 0;     /* reset task flag */
        for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++){
          uDHCPStateMachine(&DHCPContextState[uEthernetId]);
        }


#ifdef DEBUG_PRINT
        uCountDumpStats_DHCP++;
        if (uCountDumpStats_DHCP == 3000){
          uCountDumpStats_DHCP=0;
          /* dump dhcp stats to terminal once in a while */
          for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++){
            xil_printf("DHCP[%d] stats-> rx: %d, tx: %d, err: %d, invalid: %d, retry: %d\r\n", uEthernetId, DHCPContextState[uEthernetId].uDHCPRx,\
                DHCPContextState[uEthernetId].uDHCPTx, DHCPContextState[uEthernetId].uDHCPErrors,\
                DHCPContextState[uEthernetId].uDHCPInvalid, DHCPContextState[uEthernetId].uDHCPRetries);
          }
        }
#endif

      }
      /*  run the lldp task*/
      if (uFlagRunTask_LLDP){
         uFlagRunTask_LLDP = 0;     /* reset task flag */
         for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++){
           vSendLLDPPacket(uEthernetId, (u8*) uTransmitBuffer, &uResponsePacketLength);
         }
	
      }



		   for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++)
		   {
			   UpdateEthernetLinkUpStatus(uEthernetId);

			   if (uEthernetLinkUp[uEthernetId] == LINK_UP)
			   {
					uNumWords = GetHostReceiveBufferLevel(uEthernetId);
					if (uNumWords != 0)
					{
					   // Read packet into receive buffer
					   //xil_printf("Rd pkt.\r\n");
					   iStatus  = ReadHostPacket(uEthernetId, & uReceiveBuffer[0], uNumWords);
             /* TODO remove the following inline data declarations */
             u16 *buffer = (u16*) uReceiveBuffer;
             u8 *pbuffer;

					   if (iStatus == XST_SUCCESS)
					   {
						   //xil_printf("Pkt hndlr.\r\n");
						   iStatus = EthernetRecvHandler(uEthernetId, uNumWords, &uResponsePacketLength);
					   }

					   if (iStatus == XST_SUCCESS)
					   {
						   // Send the response packet now
						   uResponsePacketLength = (uResponsePacketLength >> 2);
						   iStatus = TransmitHostPacket(uEthernetId, & uTransmitBuffer[0], uResponsePacketLength);
					   }

             /* DHCP new */
             /* TODO remove the following inline data declarations */
             int size = uNumWords << 1;     /* 16bit words */
             int i;

             for (i = 0; i < size; i++){
               buffer[i] = Xil_EndianSwap16(buffer[i]);
             }

             /* validate and set flag */
             if (uDHCPMessageValidate(&DHCPContextState[uEthernetId]) == DHCP_RETURN_OK){
               uDHCPSetGotMsgFlag(&DHCPContextState[uEthernetId]);
               uFlagRunTask_DHCP = 1;   /* short-circuit the task logic and run DHCP task on next main loop iteration */
               //xil_printf("run dhcp task\n\r");
             }
             /* DHCP new */            
					}

#ifdef DO_40GBE_LOOPBACK_TEST
					// Testing 40GBE in loopback so won't get an IP address from DHCP
					if (uEthernetId != 0x0)
					{
						if (uConfig40GBE[uEthernetId - 1] == 0x1)
						{
							uConfig40GBE[uEthernetId - 1] = 0x0;
#ifdef DEBUG_PRINT
							xil_printf("ID: %x Setting IP address to: %x\r\n", uEthernetId, uTemp40GBEIPAddress);
#endif

							uDHCPState[uEthernetId] = DHCP_STATE_COMPLETE;

							uEthernetFabricIPAddress[uEthernetId] = uTemp40GBEIPAddress;

							SetFabricSourceIPAddress(uEthernetId, uEthernetFabricIPAddress[uEthernetId]);

							// Add an entry for own IP address in ARP cache table for loopback testing
#ifdef DEBUG_PRINT
							xil_printf("ARP ENTRY ID: %x IP: %x MAC: %x %x %x\r\n", uEthernetId, uTemp40GBEIPAddress, uEthernetFabricMacHigh[uEthernetId], uEthernetFabricMacMid[uEthernetId], uEthernetFabricMacLow[uEthernetId]);
#endif
							ProgramARPCacheEntry(uEthernetId, (uTemp40GBEIPAddress & 0xFF), uEthernetFabricMacHigh[uEthernetId], ((uEthernetFabricMacMid[uEthernetId] << 16) | uEthernetFabricMacLow[uEthernetId]));

#ifdef DEBUG_PRINT
							xil_printf("Enabling 40GBE ETH MAC FPGA fabric interface...\r\n");
#endif
							EnableFabricInterface(uEthernetId, 0x1);
						}
					}
#endif

#ifdef DO_1GBE_LOOPBACK_TEST
					// Testing 1GBE in loopback so won't get an IP address from DHCP
					if ((uConfig1GBE == 0x1)&&(uEthernetId == 0x0))
					{
						uConfig1GBE = 0x0;
#ifdef DEBUG_PRINT
						xil_printf("ID: %x Setting IP address to: %x\r\n", uEthernetId, uTemp1GBEIPAddress);
#endif

						uDHCPState[uEthernetId] = DHCP_STATE_COMPLETE;

						uEthernetFabricIPAddress[uEthernetId] = uTemp1GBEIPAddress;

						SetFabricSourceIPAddress(uEthernetId, uEthernetFabricIPAddress[uEthernetId]);

						// Add an entry for own IP address in ARP cache table for loopback testing
#ifdef DEBUG_PRINT
						xil_printf("ARP ENTRY ID: %x IP: %x MAC: %x %x %x\r\n", uEthernetId, uTemp1GBEIPAddress, uEthernetFabricMacHigh[uEthernetId], uEthernetFabricMacMid[uEthernetId], uEthernetFabricMacLow[uEthernetId]);
#endif

						ProgramARPCacheEntry(uEthernetId, (uTemp1GBEIPAddress & 0xFF), uEthernetFabricMacHigh[uEthernetId], ((uEthernetFabricMacMid[uEthernetId] << 16) | uEthernetFabricMacLow[uEthernetId]));

#ifdef DEBUG_PRINT
						xil_printf("Enabling 1GBE ETH MAC FPGA fabric interface...\r\n");
#endif
						EnableFabricInterface(uEthernetId, 0x1);
					}
#endif

#if 0 /* DHCP old*/
					if (((uDHCPState[uEthernetId] == DHCP_STATE_DISCOVER)||(uDHCPState[uEthernetId] == DHCP_STATE_REQUEST))&&(uDHCPRetryTimer[uEthernetId] == DHCP_RETRY_ENABLED))
					{
						uDHCPState[uEthernetId] = DHCP_STATE_DISCOVER;
						CreateDHCPDiscoverPacketOptions(uEthernetId, (u8*) uTransmitBuffer, & uDHCPOptionsLength);
						CreateDHCPPacket(uEthernetId, (u8*) uTransmitBuffer, & uResponsePacketLength, uDHCPOptionsLength);
   					    uResponsePacketLength = (uResponsePacketLength >> 2);
  					    iStatus =  TransmitHostPacket(uEthernetId, & uTransmitBuffer[0], uResponsePacketLength);
						uDHCPRetryTimer[uEthernetId] = DHCP_RETRY_DISABLED;
					}
#endif  /* DHCP old */

					if (uIGMPSendMessage[uEthernetId] == IGMP_SEND_MESSAGE)
					{
						if (uIGMPState[uEthernetId] == IGMP_STATE_JOINED_GROUP)
						{
							// Send IGMP membership reports for each IP in group
							if (uCurrentIGMPMessage[uEthernetId] <= (~uEthernetFabricMultiCastIPAddressMask[uEthernetId]))
							{
								uIGMPGroupAddress = (uEthernetFabricMultiCastIPAddress[uEthernetId] & uEthernetFabricMultiCastIPAddressMask[uEthernetId]) | uCurrentIGMPMessage[uEthernetId];
								CreateIGMPPacket(uEthernetId, (u8*) uTransmitBuffer, & uResponsePacketLength, IGMP_MEMBERSHIP_REPORT, uIGMPGroupAddress);
								uResponsePacketLength = (uResponsePacketLength >> 2);
								iStatus =  TransmitHostPacket(uEthernetId, & uTransmitBuffer[0], uResponsePacketLength);
								uCurrentIGMPMessage[uEthernetId]++;
							}
							else
								uIGMPSendMessage[uEthernetId] = IGMP_DONE_SENDING_MESSAGE;

						}
						else if (uIGMPState[uEthernetId] == IGMP_STATE_LEAVING)
						{
							// Send IGMP leave reports for each IP in group
							if (uCurrentIGMPMessage[uEthernetId] <= (~uEthernetFabricMultiCastIPAddressMask[uEthernetId]))
							{
								uIGMPGroupAddress = (uEthernetFabricMultiCastIPAddress[uEthernetId] & uEthernetFabricMultiCastIPAddressMask[uEthernetId]) | uCurrentIGMPMessage[uEthernetId];
								CreateIGMPPacket(uEthernetId, (u8*) uTransmitBuffer, & uResponsePacketLength, IGMP_LEAVE_REPORT, uIGMPGroupAddress);
								uResponsePacketLength = (uResponsePacketLength >> 2);
								iStatus =  TransmitHostPacket(uEthernetId, & uTransmitBuffer[0], uResponsePacketLength);
								uCurrentIGMPMessage[uEthernetId]++;
							}
							else
							{
								// Once finished sending all the LEAVE messages, put into IDLE state
								uIGMPState[uEthernetId] = IGMP_STATE_NOT_JOINED;
								uIGMPSendMessage[uEthernetId] = IGMP_DONE_SENDING_MESSAGE;
							}
						}

					}

			   }
		   }

		   if (uDoReboot == REBOOT_REQUESTED)
		   {
			   // Only do a reboot if all the Ethernet interfaces are no longer part of groups
			   uOKToReboot = 1;

			   for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++)
			   {
				   if (uIGMPState[uEthernetId] != IGMP_STATE_NOT_JOINED)
					   uOKToReboot = 0;

			   }

			   if (uOKToReboot == 1)
				   IcapeControllerInSystemReconfiguration();

		   }

		   // Pat the watchdog
		   XWdtTb_RestartWdt(& WatchdogTimer);
	   }

    xil_printf("---Exiting main---\n\r");
	Xil_DCacheDisable();
	Xil_ICacheDisable();
	return 0;
}


static int vSendDHCPMsg(struct sDHCPObject *pDHCPObjectPtr, void *pUserData){
  u8 uEthernetId;
  u8 r;
  u32 size;
  u16 *buffer;
  u32 uIndex;

  size = (u32) pDHCPObjectPtr->uDHCPMsgSize;    /* bytes */
  buffer = (u16 *) pDHCPObjectPtr->pUserTxBufferPtr;

  size = size >> 1;     /* 16bit words */

  for (uIndex = 0; uIndex < size; uIndex++){
    buffer[uIndex] = Xil_EndianSwap16(buffer[uIndex]);
  }

  uEthernetId = * ((u8 *) pUserData);
  size = size >> 1;   /*  32-bit words */
  r = TransmitHostPacket(uEthernetId, (u32 *) buffer, size);

  return 0;
}


void vSendLLDPPacket(u8 uEthernetId, u8 *pTransmitBuffer, u32 *uResponseLength){
  u8 r;
  u32 size;
  u16 *buffer;
  u32 uIndex;
  
  uLLDPBuildPacket(uEthernetId, pTransmitBuffer, uResponseLength);
  size = uResponseLength; // bytes/
  buffer = (u16*) pTransmitBuffer;

  size = size >> 1; /// 16bit words/
  xil_printf("size = %d\n\r", size);
  
  for(uIndex = 0; uIndex < size; uIndex++){
    buffer[uIndex] = Xil_EndianSwap16(buffer[uIndex]);
  }

  size = size >> 1;  /// 32-bit words /
  xil_printf("size = %d\n\r", size);
  r = TransmitHostPacket(uEthernetId, (u32*) &buffer[0], size);
  xil_printf("status = %d\n\r");
}


int vSetInterfaceConfig(struct sDHCPObject *pDHCPObjectPtr, void *pUserData){
  u32 ip;
  u8 id;

  id = * ((u8 *) pUserData);
  ip = pDHCPObjectPtr->arrDHCPAddrYIPCached[0] << 24 |
        pDHCPObjectPtr->arrDHCPAddrYIPCached[1] << 16 |
        pDHCPObjectPtr->arrDHCPAddrYIPCached[2] << 8 |
        pDHCPObjectPtr->arrDHCPAddrYIPCached[3];

  //xil_printf("setting ip of interface %d to %x\n\r", id, ip);

  xil_printf("DHCP [%02x] Setting IP address to: %u.%u.%u.%u\r\n", id, ((ip >> 24) & 0xFF), \ 
      ((ip >> 16) & 0xFF), \
      ((ip >> 8) & 0xFF),  \
      (ip & 0xFF));

  uEthernetFabricIPAddress[id] = ip;
  uEthernetSubnet[id] = (ip & 0xFFFFFF00);
  uEthernetGatewayIPAddress[id] = pDHCPObjectPtr->arrDHCPAddrRoute[0] << 24 |
    pDHCPObjectPtr->arrDHCPAddrRoute[1] << 16 |
    pDHCPObjectPtr->arrDHCPAddrRoute[2] << 8 |
    pDHCPObjectPtr->arrDHCPAddrRoute[3];

  ProgramARPCacheEntry(id, (ip & 0xFF), uEthernetFabricMacHigh[id], ((uEthernetFabricMacMid[id] << 16) | uEthernetFabricMacLow[id]));

	SetFabricSourceIPAddress(id, ip);

  SetFabricGatewayARPCacheAddress(id, pDHCPObjectPtr->arrDHCPAddrRoute[3]);

  uEnableArpRequests[id] = ARP_REQUESTS_ENABLE;

  /* legacy dhcp states */
  uDHCPState[id] = DHCP_STATE_COMPLETE;

  EnableFabricInterface(id, 1);

  return 0;
}
