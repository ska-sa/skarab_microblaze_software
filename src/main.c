/**-----------------------------------------------------------------------------
*FILE NAME            : main.c
* ------------------------------------------------------------------------------
*  COMPANY              : PERALEX ELECTRONIC (PTY) LTD
* ------------------------------------------------------------------------------
*  COPYRIGHT NOTICE :
*
*  The copyright, manufacturing and patent rights stemming from this
*  document in any form are vested in PERALEX ELECTRONICS (PTY) LTD.
*
*  (c) Peralex 2011
*
*  PERALEX ELECTRONICS (PTY) LTD has ceded these rights to its clients
*  where contractually agreed.
* ------------------------------------------------------------------------------
*  DESCRIPTION :
*
*  This file contains contains the top level functions for the ROACH3 uBlaze
*  embedded processor.
* ------------------------------------------------------------------------------*/

#include <stdio.h>
#include "xparameters.h"
#include "xil_cache.h"
#include "xintc.h"
#include "xwdttb.h"

#include "mb_interface.h"


#include "register.h"
#include "delay.h"
#include "eth_mac.h"
#include "flash_sdram_controller.h"
#include "icape_controller.h"
#include "isp_spi_controller.h"
#include "one_wire.h"
#include "i2c_master.h"
#include "constant_defs.h"
#include "eth_sorter.h"
#include "sensors.h"
#include "improved_read_write.h"
#include "invalid_nack.h"
#include "dhcp.h"
#include "lldp.h"
#include "icmp.h"
#include "net_utils.h"
#include "print.h"
#include "if.h"
#include "arp.h"
#include "memtest.h"

#define DHCP_BOUND_COUNTER_VALUE  600

/* local function prototypes */
static int vSendDHCPMsg(struct sIFObject *pIFObjectPtr, void *pUserData);
static int vSetInterfaceConfig(struct sIFObject *pIFObjectPtr, void *pUserData);

void DivByZeroException(void *Data);
void IBusException(void *Data);
void DBusException(void *Data);
void StackViolationException(void *Data);
void IllegalOpcodeException(void *Data);
void UnalignedAccessException(void *Data);

/* temp global definition */
static volatile u8 uFlagRunTask_DHCP = 0;
static volatile u8 uFlagRunTask_LLDP = 1; /* Set LLDP flag to 1 to send LLDP packet at start up */
static volatile u8 uFlagRunTask_CheckDHCPBound = 0;
static volatile u8 uFlagRunTask_ICMP_Reply[NUM_ETHERNET_INTERFACES] = {0};
static volatile u8 uFlagRunTask_ARP_Process[NUM_ETHERNET_INTERFACES] = {0};
static volatile u8 uFlagRunTask_ARP_Respond[NUM_ETHERNET_INTERFACES] = {0};
static volatile u8 uFlagRunTask_CTRL[NUM_ETHERNET_INTERFACES] = {0};
static volatile u8 uFlagRunTask_Diagnostics = 0;

static volatile u8 uTimeoutCounter = 255;

//u32 __attribute__ ((section(".rodata.memtest"))) __attribute__ ((aligned (32))) uMemPlace = 0xAABBCCDD ;

/* place this variable at a specific location in memory (in .rodata section). See linker script */
//u32 __attribute__ ((section(".rodata.checksum"))) __attribute__ ((aligned (32))) uMemPlace;

/* this variable holds the end address of the .text section. See linker script */
extern u32 _text_section_end_;
/* this variable holds the location at which the externally computed checksum was stored by linker. See linker script */
extern u32 _location_checksum_;

//static struct sDHCPObject DHCPContextState[NUM_ETHERNET_INTERFACES];  /* TODO can we narrow down the scope of this data? */
//static struct sICMPObject ICMPContextState[NUM_ETHERNET_INTERFACES];
static struct sIFObject IFContext[NUM_ETHERNET_INTERFACES];

//=================================================================================
//	TimerHandler
//--------------------------------------------------------------------------------
//	This method handles the interrupts generated by the Timer.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	CallBackRef			IN	Reference to timer object
//	uTimerCounterNumber	IN	There are two timers inside the timer object
//
//	Return
//	------
//	None
//=================================================================================
void TimerHandler(void * CallBackRef, u8 uTimerCounterNumber)
{
	u8 uIndex;
	u8 u40GbE1_Dhcp_En = 0;
	u8 u40GbE2_Dhcp_En = 0;
	u8 u40GbE3_Dhcp_En = 0;
	u8 u40GbE4_Dhcp_En = 0;
	u8 u40GbE1_Link_Up = 0;
	u8 u40GbE2_Link_Up = 0;
	u8 u40GbE3_Link_Up = 0;
	u8 u40GbE4_Link_Up = 0;

  if (uTimeoutCounter != 0){
    uTimeoutCounter--;
  }

	// Every 100 ms, send another ARP request
	uUpdateArpRequests = ARP_REQUEST_UPDATE;

  /* every 5 mins */
  if (uPrintStatsCounter >= 3000){
    uFlagRunTask_Diagnostics = 1;
    uPrintStatsCounter = 0;
   } else {
    uPrintStatsCounter++;
   }

  /* set the dhcp task flag every 100ms which in turn runs dhcp state machine */
  //uFlagRunTask_LLDP = 1;

	// LLDP every 10 seconds (timer every 100 ms)
	if(uLLDPTimerCounter == 0x258)
	{
		uLLDPTimerCounter = 0x0;
		uFlagRunTask_LLDP = 1;

	}
	else{
		uLLDPTimerCounter++;
	}


  /* set the dhcp task flag every 100ms which in turn runs dhcp state machine */
  uFlagRunTask_DHCP = 1;

  uFlagRunTask_CheckDHCPBound = 1;

	// DHCP every 10 seconds (timer every 100 ms)
	if (uDHCPTimerCounter == 0x64)
	{
		uDHCPTimerCounter = 0x0;

		for (uIndex = 0; uIndex < NUM_ETHERNET_INTERFACES; uIndex++)
		{
      /* TODO verify if we can remove these */
			//uDHCPRetryTimer[uIndex] = DHCP_RETRY_ENABLED;
			//uEthernetNeedsReset[uIndex] = NEEDS_RESET;

			// Send out ARP requests every 60 seconds
			if (uIGMPTimerCounter == 0x5)
			{
				uIGMPSendMessage[uIndex] = IGMP_SEND_MESSAGE;
				uCurrentIGMPMessage[uIndex] = 0x0;
			}
		}

		// Only send IGMP message reports every 60 seconds
		if (uIGMPTimerCounter == 0x5)
			uIGMPTimerCounter = 0;
		else
			uIGMPTimerCounter++;

	}
	else
		uDHCPTimerCounter++;

	uQSFPUpdateStatusEnable = UPDATE_QSFP_STATUS;

	if (uQSFPStateCounter == 0x1)
	{
		if (uQSFPState == QSFP_STATE_RESET)
		{
			uQSFPStateCounter++;
			uQSFPState = QSFP_STATE_BOOTLOADER_VERSION_WRITE_MODE;
		}
	}
	// Allow 3 seconds for QSFP+ to be ready
	//else if (uQSFPStateCounter == 0x1E)
  /* TODO: FIXME is there a better way to check for QSFP+ readiness?
                 This current mechanism is dependent on the init time
                 of main() and any changes / reordering of initialization
                 (e.g. initializing timers earlier) may result in this value
                 having to change. This may result in error messages if the
                 time allowed is too short */
	else if (uQSFPStateCounter == 0x3C)
	{
		if (uQSFPState == QSFP_STATE_STARTING_APPLICATION_MODE)
		{
			uQSFPState = QSFP_STATE_APPLICATION_MODE;
		}
	}
	else
		uQSFPStateCounter++;

  /* TODO: move the following code to main() rather */
  /* use macros for now to get rid of potential bugs and compiler warnings since
     the following code indexes the array above the array bounds if all possible
     40gbe i/f are not enabled */

#if NUM_ETHERNET_INTERFACES > 1
    //if 40GbE link 1 is up enable link else disable link
	if(IFContext[1].uIFLinkStatus == LINK_UP)
	{
		u40GbE1_Link_Up = 0x01;
		//if 40GbE DHCP is complete then set true else false
		if (uDHCPState[1] == DHCP_STATE_COMPLETE)
		{
			u40GbE1_Dhcp_En = 0x01;
		}
		else
		{
			u40GbE1_Dhcp_En = 0x00;
		}
	}
	else
	{
		u40GbE1_Link_Up = 0x00;
		u40GbE1_Dhcp_En = 0x00;
	}
#endif

#if NUM_ETHERNET_INTERFACES > 2
    //if 40GbE link 2 is up enable link else disable link
	if(IFContext[2].uIFLinkStatus == LINK_UP)
	{
		u40GbE2_Link_Up = 0x01;
		//if 40GbE DHCP is complete then set true else false
		if (uDHCPState[2] == DHCP_STATE_COMPLETE)
		{
			u40GbE2_Dhcp_En = 0x01;
		}
		else
		{
			u40GbE2_Dhcp_En = 0x00;
		}
	}
	else
	{
		u40GbE2_Link_Up = 0x00;
		u40GbE2_Dhcp_En = 0x00;
	}
#endif

#if NUM_ETHERNET_INTERFACES > 3
    //if 40GbE link 3 is up enable link else disable link
	if(IFContext[3].uIFLinkStatus == LINK_UP)
	{
		u40GbE3_Link_Up = 0x01;
		//if 40GbE DHCP is complete then set true else false
		if (uDHCPState[3] == DHCP_STATE_COMPLETE)
		{
			u40GbE3_Dhcp_En = 0x01;
		}
		else
		{
			u40GbE3_Dhcp_En = 0x00;
		}
	}
	else
	{
		u40GbE3_Link_Up = 0x00;
		u40GbE3_Dhcp_En = 0x00;
	}
#endif

#if NUM_ETHERNET_INTERFACES > 4
    //if 40GbE link 4 is up enable link else disable link
	if(IFContext[4].uIFLinkStatus == LINK_UP)
	{
		u40GbE4_Link_Up = 0x01;
		//if 40GbE DHCP is complete then set true else false
		if (uDHCPState[4] == DHCP_STATE_COMPLETE)
		{
			u40GbE4_Dhcp_En = 0x01;
		}
		else
		{
			u40GbE4_Dhcp_En = 0x00;
		}
	}
	else
	{
		u40GbE4_Link_Up = 0x00;
		u40GbE4_Dhcp_En = 0x00;
	}
#endif

	uFrontPanelLedsValue = u40GbE4_Link_Up <<7 | u40GbE4_Dhcp_En <<6 | u40GbE3_Link_Up <<5 | u40GbE3_Dhcp_En <<4 | u40GbE2_Link_Up<<3 | u40GbE2_Dhcp_En<<2 | u40GbE1_Link_Up<<1 | u40GbE1_Dhcp_En;
	WriteBoardRegister(C_WR_FRONT_PANEL_STAT_LED_ADDR, uFrontPanelLedsValue);

/*  // Flash front panel LEDS until 1GBE has completed DHCP
	if (uDHCPState[0] != DHCP_STATE_COMPLETE)
	{
		uDHCPCompleteSetLeds = FALSE;
		if (uFrontPanelTimerCounter == 0xA)
		{
			if (uFrontPanelLeds == LED_OFF)
			{
				uFrontPanelLeds = LED_ON;
				WriteBoardRegister(C_WR_FRONT_PANEL_STAT_LED_ADDR, 0xFF);
			}
			else
			{
				uFrontPanelLeds = LED_OFF;
				WriteBoardRegister(C_WR_FRONT_PANEL_STAT_LED_ADDR, 0x00);
			}

			uFrontPanelTimerCounter = 0x0;
		}
		else
			uFrontPanelTimerCounter++;
	}
	else
	{
		if (uDHCPCompleteSetLeds == FALSE)
		{
			uDHCPCompleteSetLeds = TRUE;
			uFrontPanelLeds = LED_ON;
			WriteBoardRegister(C_WR_FRONT_PANEL_STAT_LED_ADDR, 0xFF);
		}
	}
*/

}



//=================================================================================
//	EthernetRecvHandler
//--------------------------------------------------------------------------------
//	This method processes a packet stored in uReceiveBuffer.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	uId			IN		ID of network interface that packet was received from
//	uNumWords	IN		Packet size in 32 bit words
//	uResponsePacketLength	OUT	Length of response packet in bytes
//
//	Return
//	------
//	XST_SUCCESS if successful
//=================================================================================
int EthernetRecvHandler(u8 uId, u32 uNumWords, u32 * uResponsePacketLengthBytes)
{
	// L2 - Ethernet
	// L3 - IP(v4) / ARP
	// L4 - UDP
	// L5 - command protocol
	u32 uL2PktLen;
	u32 uL3PktLen;
	u32 uL4PktLen;
	u32 uL5PktLen;
	u8 *pL2Ptr;
	u8 *pL3Ptr;
	u8 *pL4Ptr;
	u8 *pL5Ptr;
	u8 *uResponsePacketPtr;
	u32 uResponseLength;

	uResponsePacketPtr = (u8*) (uTransmitBuffer);
	uResponsePacketPtr = uResponsePacketPtr + sizeof(sEthernetHeaderT) + sizeof(sIPV4HeaderT) + sizeof(sUDPHeaderT);

	struct sEthernetHeader *EthHdr;
	u32 uL3Proto;
	u32 uL3TOS;
	u32 uUdpSrcPort;
	u32 uUdpDstPort;
	int iStatus;

	// Check we have enough data to proceed: i.e. at least valid Ethernet header
	uL2PktLen = uNumWords * 4;

  trace_printf("Ethernet Receive Handler\n\r");

	if (uL2PktLen < sizeof(struct sEthernetHeader))
		return XST_FAILURE;

	pL2Ptr = (u8 *) &(uReceiveBuffer[uId][0]);
	EthHdr = (struct sEthernetHeader *) pL2Ptr;

	// Cache MAC source address for response
	uResponseMacHigh = EthHdr->uSourceMacHigh;
	uResponseMacMid = EthHdr->uSourceMacMid;
	uResponseMacLow = EthHdr->uSourceMacLow;

	pL3Ptr = pL2Ptr + sizeof(struct sEthernetHeader);
	uL3PktLen = uL2PktLen - sizeof(struct sEthernetHeader);

	// TO DO: HANDLE ALL NON-IP/UDP PACKETS HERE
	if (EthHdr->uEthernetType == ETHERNET_TYPE_ARP){
		iStatus = CheckArpRequest(uId, uEthernetFabricIPAddress[uId], uL3PktLen, pL3Ptr);
		if (iStatus == XST_SUCCESS){
#ifdef DEBUG_PRINT
			//xil_printf("ARP packet received!\r\n");
#endif
			ArpHandler(uId, ARP_RESPONSE, pL3Ptr, (u8 *) uTransmitBuffer, uResponsePacketLengthBytes, 0x0);
			return XST_SUCCESS;
		} else {
			return XST_FAILURE;
    }
	}	else if (EthHdr->uEthernetType == ETHERNET_TYPE_IPV4)	{
		trace_printf("IP packet received!\r\n");
		iStatus = CheckIPV4Header(uEthernetFabricIPAddress[uId], uEthernetFabricSubnetMask[uId], uL3PktLen, pL3Ptr);
		if (iStatus == XST_SUCCESS){
			pL4Ptr = ExtractIPV4FieldsAndGetPayloadPointer(pL3Ptr, &uL4PktLen, (u32 *) &uResponseIPAddr, &uL3Proto, &uL3TOS);
			if (uL3Proto == IP_PROTOCOL_UDP){
				trace_printf("UDP packet received!\r\n");
				iStatus = CheckUdpHeader(pL3Ptr, uL4PktLen, pL4Ptr);
				if (iStatus == XST_SUCCESS){
          trace_printf("UDP packet success!\r\n");
					pL5Ptr = ExtractUdpFieldsAndGetPayloadPointer(pL4Ptr,& uL5PktLen, & uUdpSrcPort, & uUdpDstPort);
					uResponseUDPPort = uUdpSrcPort;
					// Command protocol
					if (uUdpDstPort == ETHERNET_CONTROL_PORT_ADDRESS){
            trace_printf("Control packet received!\r\n");
						iStatus = CommandSorter(uId, pL5Ptr, uL5PktLen, uResponsePacketPtr, & uResponseLength);
						if (iStatus == XST_SUCCESS){
              trace_printf("Control packet success\r\n");
							// Create rest of Ethernet packet in transmit buffer for response
							CreateResponsePacket(uId, (u8 *) uTransmitBuffer, uResponseLength);
							* uResponsePacketLengthBytes = (uResponseLength + sizeof(sEthernetHeaderT) + sizeof(sIPV4HeaderT) + sizeof(sUDPHeaderT));
							return XST_SUCCESS;
						}	else {
							return XST_FAILURE;
            }
					}	else {
						return XST_FAILURE;
          }
				}	else {
          xil_printf("check UDP header failed: src mac %04x.%04x.%04x\r\n", EthHdr->uSourceMacHigh, EthHdr->uSourceMacMid, EthHdr->uSourceMacLow);
					return XST_FAILURE;
        }
			} else {
				return XST_FAILURE;
      }
		}	else {
			return XST_FAILURE;
    }
	} else {
		return XST_FAILURE;
  }

}

typedef enum {
  /* these are enumerations for protocols we are expecting */
  PACKET_FILTER_ARP,
  PACKET_FILTER_ICMP,
  PACKET_FILTER_DHCP,
  PACKET_FILTER_CONTROL,
  /* these are enumerations to handle unexpected packets or errors */
  PACKET_FILTER_UNKNOWN,
  PACKET_FILTER_ERROR,
  PACKET_FILTER_DROP,
  PACKET_FILTER_UNKNOWN_UDP,
  PACKET_FILTER_UNKNOWN_IP,
  PACKET_FILTER_UNKNOWN_ETH
} typePacketFilter;

#if 0
#define PACKET_FILTER_UNKNOWN 0
#define PACKET_FILTER_ERROR   1
#define PACKET_FILTER_ARP     2
#define PACKET_FILTER_ICMP    3
#define PACKET_FILTER_DHCP    4
#define PACKET_FILTER_CONTROL 5

#define PACKET_FILTER_DROP        252
#define PACKET_FILTER_UNKNOWN_UDP 253
#define PACKET_FILTER_UNKNOWN_IP  254
#define PACKET_FILTER_UNKNOWN_ETH 255
#endif

#define ETHER_TYPE_ARP    0x0806
#define ETHER_TYPE_IPV4   0x0800

#define IPV4_TYPE_ICMP   0x0001
#define IPV4_TYPE_UDP    0x0011

#define UDP_CONTROL_PORT  0x7778
#define BOOTP_CLIENT_PORT 0x44
#define BOOTP_SERVER_PORT 0x43

//=================================================================================
//  uRecvPacketFilter
//---------------------------------------------------------------------------------
//  This method applies the packet filtering per layer.
//
//  Parameter	      Dir   Description
//  ---------	      ---	  -----------
//  pIFObjectPtr    IN    handle to IF state object
//
//  Return
//  ------
//  typePacketFilter
//=================================================================================
typePacketFilter uRecvPacketFilter(struct sIFObject *pIFObjectPtr){
  u16 uL2Type;    /* implemented: Ethernet Frame Type filtering => ARP, IPv4 */
  u8 uL3Type;    /* implemented: IPv4 Protocol Type filtering => ICMP, UDP */

                  /* implemented: UDP Datagram Port filtering => DHCP, CONTROL */
  u16 uUDPSrcPort = 0;
  u16 uUDPDstPort = 0;

  u8 uIPHdrLenAdjust = 0;

  typePacketFilter uReturnType = PACKET_FILTER_UNKNOWN;

  u8 *pRxBuffer = NULL;

  trace_printf("Running packet filter...\r\n");

  if (pIFObjectPtr == NULL){
    return PACKET_FILTER_ERROR;
  }

  pRxBuffer = pIFObjectPtr->pUserRxBufferPtr;
  if (pRxBuffer == NULL){
    return PACKET_FILTER_ERROR;
  }

  pIFObjectPtr->uRxTotal++;

  /* inspect the ethernet frame type */
  uL2Type = (pRxBuffer[ETH_FRAME_TYPE_OFFSET] << 8) & 0xff00;
  uL2Type = uL2Type | (pRxBuffer[ETH_FRAME_TYPE_OFFSET + 1] & 0xff);
  trace_printf("layer2 type 0x%04x\n\r",uL2Type);


  switch(uL2Type){
    case ETHER_TYPE_ARP:
      trace_printf("ARP packet received!\r\n");
      pIFObjectPtr->uRxEthArp++;
      uReturnType = PACKET_FILTER_ARP;
      /* no further filtering required */
      break;

    case ETHER_TYPE_IPV4:
      /* further filtering required on ip packet */
      /* inspect the ip header protocol type */
      trace_printf("IP packet received!\r\n"); 
      pIFObjectPtr->uRxEthIp++;
      uL3Type = pRxBuffer[IP_FRAME_BASE + IP_PROT_OFFSET] & 0xff;
      switch(uL3Type){
        case IPV4_TYPE_ICMP:
          trace_printf("ICMP packet received!\r\n");
          pIFObjectPtr->uRxIpIcmp++;
          uReturnType = PACKET_FILTER_ICMP;
          /* no further filtering required */
          break;

        case IPV4_TYPE_UDP:
          trace_printf("UDP packet received!\r\n");
          pIFObjectPtr->uRxIpUdp++;
          /* further filtering required on udp datagram */
          /* allow for variable ip header lengths */
          /* adjust ip base value if ip length greater than 20 bytes. Min header length = 20 bytes; Max header length = 60 bytes */
          uIPHdrLenAdjust = (((pRxBuffer[IP_FRAME_BASE] & 0x0F) * 4) - 20);
          if (uIPHdrLenAdjust > 40){
            error_printf("IP header length adjustment of %d seems incorrect!\n\r", uIPHdrLenAdjust);
            return PACKET_FILTER_ERROR;
          }

          /* inspect the udp header port values */
          uUDPSrcPort = (pRxBuffer[uIPHdrLenAdjust + UDP_FRAME_BASE + UDP_SRC_PORT_OFFSET] << 8) & 0xff00;
          uUDPSrcPort = uUDPSrcPort | (pRxBuffer[uIPHdrLenAdjust + UDP_FRAME_BASE + UDP_SRC_PORT_OFFSET + 1] & 0xff);

          uUDPDstPort = (pRxBuffer[uIPHdrLenAdjust + UDP_FRAME_BASE + UDP_DST_PORT_OFFSET] << 8) & 0xff00;
          uUDPDstPort = uUDPDstPort | (pRxBuffer[uIPHdrLenAdjust + UDP_FRAME_BASE + UDP_DST_PORT_OFFSET + 1] & 0xff);

          if (uUDPDstPort == UDP_CONTROL_PORT){
            trace_printf("CONTROL packet received!\r\n");
            pIFObjectPtr->uRxUdpCtrl++;
            uReturnType = PACKET_FILTER_CONTROL;
          } else if ((uUDPDstPort == BOOTP_CLIENT_PORT) && (uUDPSrcPort == BOOTP_SERVER_PORT)){
            trace_printf("DHCP packet received!\r\n");
            pIFObjectPtr->uRxUdpDhcp++;
            uReturnType = PACKET_FILTER_DHCP;
          } else if ((uUDPDstPort == BOOTP_SERVER_PORT) && (uUDPSrcPort == BOOTP_CLIENT_PORT)){
            /* These packets are broadcast  DISCOVER / REQUEST packets from other network nodes / SKARABs
               can probably safely drop these packets */
            trace_printf("DHCP packet destined for DHCP server received! Can probably safely drop packet!\r\n");
            pIFObjectPtr->uRxUdpUnknown++;
            uReturnType = PACKET_FILTER_DROP;
          } else {
            debug_printf("UNKNOWN UDP ports: [src] 0x%04x & [dst] 0x%04x!\r\n", uUDPSrcPort, uUDPDstPort);
            pIFObjectPtr->uRxUdpUnknown++;
            uReturnType = PACKET_FILTER_UNKNOWN_UDP;
          }
          break;

        default:
          debug_printf("UNKNOWN IP protocol 0x%02x received!\r\n", uL3Type);
          pIFObjectPtr->uRxIpUnknown++;
          uReturnType = PACKET_FILTER_UNKNOWN_IP;
          break;
      }
      break;

    default:
      /* Handle unimplemented / unknown ethernet frames */
      debug_printf("UNKNOWN ETH type 0x%04x packet received!\r\n", uL2Type);
      pIFObjectPtr->uRxEthUnknown++;
      uReturnType = PACKET_FILTER_UNKNOWN_ETH;
      break;
  }

  return uReturnType;
}

//=================================================================================
//	ArpRequestHandler
//--------------------------------------------------------------------------------
//	This method constucts ARP requests to populate the ARP caches in the fabric
//	Ethernet interfaces.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void ArpRequestHandler()
{
	u32 uCurrentArpRequestIPAddress;
	u32 uResponseLength;
  int iStatus;

	uUpdateArpRequests = ARP_REQUEST_DONT_UPDATE;

	if (uEnableArpRequests[uCurrentArpEthernetInterface] == ARP_REQUESTS_ENABLE)
	{
	   	// Create an ARP request
	    uCurrentArpRequestIPAddress = uEthernetSubnet[uCurrentArpEthernetInterface] | uCurrentArpRequest;
	    ArpHandler(uCurrentArpEthernetInterface, ARP_REQUEST, (u8*) &(uReceiveBuffer[uCurrentArpEthernetInterface][0]), (u8*) uTransmitBuffer, & uResponseLength, uCurrentArpRequestIPAddress);
	   	uResponseLength = (uResponseLength >> 2);
	    iStatus = TransmitHostPacket(uCurrentArpEthernetInterface, & uTransmitBuffer[0], uResponseLength);
      if (iStatus != XST_SUCCESS){
        IFContext[uCurrentArpEthernetInterface].uTxEthArpErr++;
      } else {
        IFContext[uCurrentArpEthernetInterface].uTxEthArpRequestOk++;
      }
	}

    if (uCurrentArpRequest == 254)
    {
		uCurrentArpRequest = 1;

		if ((uCurrentArpEthernetInterface + 1) == NUM_ETHERNET_INTERFACES)
    		uCurrentArpEthernetInterface = 0;
    	else
    		uCurrentArpEthernetInterface++;
    }
    else
    	uCurrentArpRequest++;
}

//=================================================================================
//	UpdateEthernetLinkUpStatus
//--------------------------------------------------------------------------------
//	This method updates the Ethernet link up status. The Ethernet interface is not
//	checked for received messages if it is not up. When the Ethernet link comes up,
//	the ARP packet requests are enabled to populate the ARP cache.
//
//	Parameter	      Dir   Description
//	---------       ---   -----------
//	pIFObjectPtr		IN    handle to IF State Object
//
//	Return
//	------
//	None
//=================================================================================
void UpdateEthernetLinkUpStatus(struct sIFObject *pIFObjectPtr){
  u32 uReg, uMask;
  u8 uId;

  /* TODO: pIFObjectPtr sanity checks - is it necessary? */

  uId = pIFObjectPtr->uIFEthernetId;

  uReg = ReadBoardRegister(C_RD_ETH_IF_LINK_UP_ADDR);
  uMask = 1 << uId;

  if ((uReg & uMask) != LINK_DOWN){
    // Check if the link was previously down
    if (pIFObjectPtr->uIFLinkStatus == LINK_DOWN){
      xil_printf("LINK %x HAS COME UP!\r\n",uId);
 
      if (uId == 0){  /* 1gbe i/f */
        /* do not enable dhcp in loopback mode */
#ifndef DO_1GBE_LOOPBACK_TEST
        vDHCPStateMachineReset(&IFContext[uId]);
        uDHCPSetStateMachineEnable(&IFContext[uId], SM_TRUE);
#endif
      } else {    /* for all other i/f's i.e. the 40gbe i/f's */
        /* do not enable dhcp in loopback mode */
#ifndef DO_40GBE_LOOPBACK_TEST
        vDHCPStateMachineReset(&IFContext[uId]);
        uDHCPSetStateMachineEnable(&IFContext[uId], SM_TRUE);
#endif
      }
    }

    pIFObjectPtr->uIFLinkStatus = LINK_UP;
  } else {
    // Check if the link was previously up
    if (pIFObjectPtr->uIFLinkStatus == LINK_UP){
      xil_printf("LINK %x HAS GONE DOWN!\r\n", uId);

      if (uId == 0){  /* 1gbe i/f */
        /* do not set in loopback mode */
#ifndef DO_1GBE_LOOPBACK_TEST
        vDHCPStateMachineReset(&IFContext[uId]); /* this will reset and disable dhcp state machine */
        uEthernetFabricIPAddress[uId] = 0;
        uEthernetGatewayIPAddress[uId] = 0;
        uEthernetSubnet[uId] = 0;
#endif
      } else {
        /* do not set in loopback mode */
#ifndef DO_40GBE_LOOPBACK_TEST
        vDHCPStateMachineReset(&IFContext[uId]); /* this will reset and disable dhcp state machine */
        uEthernetFabricIPAddress[uId] = 0;
        uEthernetGatewayIPAddress[uId] = 0;
        uEthernetSubnet[uId] = 0;
#endif
      }
    }

    pIFObjectPtr->uIFLinkStatus = LINK_DOWN;
    uEnableArpRequests[uId] = ARP_REQUESTS_DISABLE;

    uIGMPState[uId] = IGMP_STATE_NOT_JOINED;
  }
}

//=================================================================================
//	UpdateQSFPStatus
//--------------------------------------------------------------------------------
//	This method updates the status of modules present and LEDs.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void UpdateQSFPStatus()
{
	u16 uWriteBytes[7];
	u16 uReadBytes[3];
	int iStatus = XST_SUCCESS;
	u32 uReg;
	u8 uId = 0x0;
	u32 uLedTxReg = 0x0;
	u32 uLedRxReg = 0x0;
	u32 uLinkMask = 0x10000;
	u32 uActivityMask = 0x20000;

	if ((uPxSerialNumber == 93121)&&(uQSFPMezzanineLocation == 1))
	{
		// ONE OF THE PROTOTYPE SYSTEMS HAS A PROBLEM WITH I2C ON MEZZANINE SITE 1
		// BRING ALL CHANNELS OUT OF RESET
		// DON'T TRY TO ACCESS I2C
		uQSFPCtrlReg = 0x0;
		WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
	}
	else
	{
		if (uQSFPUpdateStatusEnable == UPDATE_QSFP_STATUS)
		{
			uQSFPUpdateStatusEnable = DO_NOT_UPDATE_QSFP_STATUS;

			if (uQSFPState == QSFP_STATE_BOOTLOADER_VERSION_WRITE_MODE)
			{
				// Need to read and store QSFP+ bootloader version before exit bootloader mode
				uWriteBytes[0] = QSFP_BOOTLOADER_READ_OPCODE;
				uWriteBytes[1] = ((QSFP_BOOTLOADER_VERSION_ADDRESS >> 24) & 0xFF);
				uWriteBytes[2] = ((QSFP_BOOTLOADER_VERSION_ADDRESS >> 16) & 0xFF);
				uWriteBytes[3] = ((QSFP_BOOTLOADER_VERSION_ADDRESS >> 8) & 0xFF);
				uWriteBytes[4] = (QSFP_BOOTLOADER_VERSION_ADDRESS & 0xFF);
				uWriteBytes[5] = 0x01; // Reading 1 byte
				//xil_printf("QSFP+ Mezzanine writing version address.\r\n");

				iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_BOOTLOADER_SLAVE_ADDRESS, uWriteBytes, 6);

				if (iStatus != XST_SUCCESS)
					xil_printf("BOOTLOADER I2C WRITE FAILED\r\n");

				uQSFPState = QSFP_STATE_BOOTLOADER_VERSION_READ_MODE;
			}
			else if (uQSFPState == QSFP_STATE_BOOTLOADER_VERSION_READ_MODE)
			{
				//xil_printf("QSFP+ Mezzanine reading bootloader version.\r\n");

				iStatus = ReadI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_BOOTLOADER_SLAVE_ADDRESS, uReadBytes, 1);

				if (iStatus != XST_SUCCESS)
					xil_printf("BOOTLOADER I2C READ FAILED\r\n");

				uQSFPBootloaderVersionMajor = (uReadBytes[0] >> 4) & 0xF;
				uQSFPBootloaderVersionMinor = uReadBytes[0] & 0xF;

				xil_printf("QSFP+ Mezzanine bootloader version: %x.%x\r\n", uQSFPBootloaderVersionMajor, uQSFPBootloaderVersionMinor);

				uQSFPState = QSFP_STATE_INITIAL_BOOTLOADER_MODE;
			}
			else if(uQSFPState == QSFP_STATE_INITIAL_BOOTLOADER_MODE)
			{
				uWriteBytes[0] = QSFP_LEAVE_BOOTLOADER_MODE;
				xil_printf("QSFP+ Mezzanine leaving bootloader mode.\r\n");

				iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_BOOTLOADER_SLAVE_ADDRESS, uWriteBytes, 1);

				if (iStatus != XST_SUCCESS)
					xil_printf("BOOTLOADER I2C WRITE FAILED\r\n");

				uQSFPState = QSFP_STATE_STARTING_APPLICATION_MODE;
				//uQSFPStateCounter = 0;
			}
			else if (uQSFPState == QSFP_STATE_APPLICATION_MODE)
			{
				if (uQSFPI2CMicroblazeAccess == QSFP_I2C_MICROBLAZE_ENABLE)
				{
					if (uQSFPUpdateState == QSFP_UPDATING_TX_LEDS)
					{
						uQSFPUpdateState = QSFP_UPDATING_RX_LEDS;

						uReg = ReadBoardRegister(C_RD_ETH_IF_LINK_UP_ADDR);
						//xil_printf("uReg: %x\r\n", uReg);

#ifdef SKARAB_BSP
						for (uId = 0x0; uId < 0x4; uId++)
#else
						for (uId = 0x0; uId < (NUM_ETHERNET_INTERFACES - 1); uId++)
#endif
						{
							// Check TX link
							if ((uReg & uLinkMask) != 0x0)
							{
								// Check if activity as well
								if ((uReg & uActivityMask) != 0x0)
									uLedTxReg = uLedTxReg | (LED_FLASHING << (uId * 2));
								else
									uLedTxReg = uLedTxReg | (LED_ON << (uId * 2));
							}
							else
								uLedTxReg = uLedTxReg | (LED_OFF << (uId * 2));

							uLinkMask = uLinkMask << 2;
							uActivityMask = uActivityMask << 2;

							// Check RX link
							if ((uReg & uLinkMask) != 0x0)
							{
								// Check if activity as well
								if ((uReg & uActivityMask) != 0x0)
									uLedRxReg = uLedRxReg | (LED_FLASHING << (uId * 2));
								else
									uLedRxReg = uLedRxReg | (LED_ON << (uId * 2));
							}
							else
								uLedRxReg = uLedRxReg | (LED_OFF << (uId * 2));

							uLinkMask = uLinkMask << 2;
							uActivityMask = uActivityMask << 2;
						}

						// GT 04/06/2015 CHANGE TO ALWAYS WRITE if (uLedTxReg != uQSFPMezzanineCurrentTxLed)
						//{
							uWriteBytes[0] = QSFP_LED_TX_REG_ADDRESS;
							uWriteBytes[1] = uLedTxReg;
							iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uWriteBytes, 2);

							if (iStatus != XST_SUCCESS)
								xil_printf("TX LED MEZ I2C WRITE FAILED\r\n");

							//xil_printf("uLedTxReg: %x\r\n", uLedTxReg);
							uQSFPMezzanineCurrentTxLed = uLedTxReg;
						//}
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_RX_LEDS)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_0_WRITE;

						uReg = ReadBoardRegister(C_RD_ETH_IF_LINK_UP_ADDR);

#ifdef SKARAB_BSP
						for (uId = 0x0; uId < 0x4; uId++)
#else
						for (uId = 0x0; uId < (NUM_ETHERNET_INTERFACES - 1); uId++)
#endif
						{
							// Check TX link
							if ((uReg & uLinkMask) != 0x0)
							{
								// Check if activity as well
								if ((uReg & uActivityMask) != 0x0)
									uLedTxReg = uLedTxReg | (LED_FLASHING << (uId * 2));
								else
									uLedTxReg = uLedTxReg | (LED_ON << (uId * 2));
							}
							else
								uLedTxReg = uLedTxReg | (LED_OFF << (uId * 2));

							uLinkMask = uLinkMask << 2;
							uActivityMask = uActivityMask << 2;

							// Check RX link
							if ((uReg & uLinkMask) != 0x0)
							{
								// Check if activity as well
								if ((uReg & uActivityMask) != 0x0)
									uLedRxReg = uLedRxReg | (LED_FLASHING << (uId * 2));
								else
									uLedRxReg = uLedRxReg | (LED_ON << (uId * 2));
							}
							else
								uLedRxReg = uLedRxReg | (LED_OFF << (uId * 2));

							uLinkMask = uLinkMask << 2;
							uActivityMask = uActivityMask << 2;
						}

						// GT 04/06/2015 CHANGE TO ALWAYS WRITE if (uLedRxReg != uQSFPMezzanineCurrentRxLed)
						//{
							uWriteBytes[0] = QSFP_LED_RX_REG_ADDRESS;
							uWriteBytes[1] = uLedRxReg;
							iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uWriteBytes, 2);

							if (iStatus != XST_SUCCESS)
								xil_printf("RX LED MEZ I2C WRITE FAILED\r\n");

							//xil_printf("uLedRxReg: %x\r\n", uLedRxReg);
							uQSFPMezzanineCurrentRxLed = uLedRxReg;
						//}
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_0_WRITE)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_0_READ;

						uWriteBytes[0] = QSFP_MODULE_0_PRESENT_REG_ADDRESS;
						iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uWriteBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 0 MEZ I2C WRITE FAILED\r\n");
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_0_READ)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_1_WRITE;

						iStatus = ReadI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uReadBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 0 MEZ I2C READ FAILED\r\n");

						if (uReadBytes[0] != 0x0)
							// If a module is present, take out of reset
							uQSFPCtrlReg = uQSFPCtrlReg & (~ QSFP0_RESET);
						else
							// If a module is not present, put in reset
							uQSFPCtrlReg = uQSFPCtrlReg | QSFP0_RESET;

						WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_1_WRITE)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_1_READ;

						uWriteBytes[0] = QSFP_MODULE_1_PRESENT_REG_ADDRESS;
						iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uWriteBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 1 MEZ I2C WRITE FAILED\r\n");
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_1_READ)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_2_WRITE;

						iStatus = ReadI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uReadBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 1 MEZ I2C READ FAILED\r\n");

						if (uReadBytes[0] != 0x0)
							// If a module is present, take out of reset
							uQSFPCtrlReg = uQSFPCtrlReg & (~ QSFP1_RESET);
						else
							// If a module is not present, put in reset
							uQSFPCtrlReg = uQSFPCtrlReg | QSFP1_RESET;

						WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_2_WRITE)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_2_READ;

						uWriteBytes[0] = QSFP_MODULE_2_PRESENT_REG_ADDRESS;
						iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uWriteBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 2 MEZ I2C WRITE FAILED\r\n");
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_2_READ)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_3_WRITE;

						iStatus = ReadI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uReadBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 2 MEZ I2C READ FAILED\r\n");

						if (uReadBytes[0] != 0x0)
							// If a module is present, take out of reset
							uQSFPCtrlReg = uQSFPCtrlReg & (~ QSFP2_RESET);
						else
							// If a module is not present, put in reset
							uQSFPCtrlReg = uQSFPCtrlReg | QSFP2_RESET;

						WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_3_WRITE)
					{
						uQSFPUpdateState = QSFP_UPDATING_MOD_PRSNT_3_READ;

						uWriteBytes[0] = QSFP_MODULE_3_PRESENT_REG_ADDRESS;
						iStatus = WriteI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uWriteBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 3 MEZ I2C WRITE FAILED\r\n");
					}
					else if (uQSFPUpdateState == QSFP_UPDATING_MOD_PRSNT_3_READ)
					{
						uQSFPUpdateState = QSFP_UPDATING_TX_LEDS;

						iStatus = ReadI2CBytes(uQSFPMezzanineLocation + 1, QSFP_STM_I2C_SLAVE_ADDRESS, uReadBytes, 1);

						if (iStatus != XST_SUCCESS)
							xil_printf("MOD 3 MEZ I2C READ FAILED\r\n");

						if (uReadBytes[0] != 0x0)
							// If a module is present, take out of reset
							uQSFPCtrlReg = uQSFPCtrlReg & (~ QSFP3_RESET);
						else
							// If a module is not present, put in reset
							uQSFPCtrlReg = uQSFPCtrlReg | QSFP3_RESET;

						WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);
					}
				}
			}
		}
	}
}

//=================================================================================
//	InitialiseEthernetInterfaceParameters
//--------------------------------------------------------------------------------
//	This method configures the Ethernet interfaces with some default values.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void InitialiseEthernetInterfaceParameters()
{
	u8 uId;
	u16 uRom[8];
	u16 uSerial[4];
	u16 uFabricMacHigh;
	u16 uFabricMacMid;
	u16 uFabricMacLow;
	u16 uPxSerial[3];
	int iSuccess;
	u16 uRomCRC;

	uCurrentArpEthernetInterface = 0;
	uCurrentArpRequest = 1;
	uUpdateArpRequests = ARP_REQUEST_DONT_UPDATE;
	uDHCPCompleteSetLeds = FALSE;
	uPreviousAsyncSdramRead = 0;
	uPreviousSequenceNumber = 0;

	iSuccess = OneWireReadRom(uRom, MB_ONE_WIRE_PORT);

	if (iSuccess == XST_SUCCESS)
	{
		// GT 05/06/2015 CHECK CRC OF ROM TO CONFIRM OK
		uRomCRC = OneWireCrc8(& uRom[0], 0x7);
		if (uRomCRC != uRom[7])
		{
			xil_printf("MB 1-wire CRC incorrect.\r\n");
			uSerial[0] = 0xFF;
			uSerial[1] = 0xFF;
			uSerial[2] = 0xFF;
			uSerial[3] = 0xFF;
		}
		else
		{
			// Read the serial number
			iSuccess = DS2433ReadMem(uRom, 0, uSerial, 4, 0, 0, MB_ONE_WIRE_PORT);

			if (iSuccess == XST_FAILURE)
			{
				xil_printf("Failed to read serial number.\r\n");
				uSerial[0] = 0xFF;
				uSerial[1] = 0xFF;
				uSerial[2] = 0xFF;
				uSerial[3] = 0xFF;
			}
		}
	}
	else
	{
		xil_printf("Failed to read serial number.\r\n");
		uSerial[0] = 0xFF;
		uSerial[1] = 0xFF;
		uSerial[2] = 0xFF;
		uSerial[3] = 0xFF;
	}

	// GT 04/06/2015 BASIC SANITY CHECK, IF FAILS TRY TO READ ONE MORE TIME
	if (uSerial[0] != 0x50) // CHECK FOR 'P'
	{
		xil_printf("Trying again to read serial number.\r\n");

		iSuccess = OneWireReadRom(uRom, MB_ONE_WIRE_PORT);

		if (iSuccess == XST_SUCCESS)
		{
			// GT 05/06/2015 CHECK CRC OF ROM TO CONFIRM OK
			uRomCRC = OneWireCrc8(& uRom[0], 0x7);
			if (uRomCRC != uRom[7])
			{
				xil_printf("MB 1-wire CRC incorrect.\r\n");
				uSerial[0] = 0xFF;
				uSerial[1] = 0xFF;
				uSerial[2] = 0xFF;
				uSerial[3] = 0xFF;
			}
			else
			{
				// Read the serial number
				iSuccess = DS2433ReadMem(uRom, 0, uSerial, 4, 0, 0, MB_ONE_WIRE_PORT);

				if (iSuccess == XST_FAILURE)
				{
					xil_printf("Failed to read serial number.\r\n");
					uSerial[0] = 0xFF;
					uSerial[1] = 0xFF;
					uSerial[2] = 0xFF;
					uSerial[3] = 0xFF;
				}
			}
		}
		else
		{
			xil_printf("Failed to read serial number.\r\n");
			uSerial[0] = 0xFF;
			uSerial[1] = 0xFF;
			uSerial[2] = 0xFF;
			uSerial[3] = 0xFF;
		}
	}

	// TO DO: NOT SURE WHAT TO DO HERE FOR MULTICAST
	uFabricMacHigh = 0x0600 | uSerial[0];
	uFabricMacMid = (uSerial[1] << 8) | uSerial[2];

	for (uId = 0; uId < NUM_ETHERNET_INTERFACES; uId++)
	{
		uEnableArpRequests[uId] = ARP_REQUESTS_DISABLE;
		//uEthernetLinkUp[uId] = LINK_DOWN;
		uEthernetFabricSubnetMask[uId] = ETHERNET_FABRIC_SUBNET_MASK;
		uEthernetFabricPortAddress[uId] = ETHERNET_FABRIC_PORT_ADDRESS;
		uEthernetSubnet[uId] = ETHERNET_FABRIC_SUBNET;
		uIPIdentification[uId] = 0x7342;

#ifdef DO_40GBE_LOOPBACK_TEST
		xil_printf("Setting all 40GBE MAC addresses same so can test in loopback!\r\n");
		if (uId == 0)
			uFabricMacLow = (uSerial[3] << 8) | uId;
		else
			uFabricMacLow = (uSerial[3] << 8) | 0x1;
#else
		uFabricMacLow = (uSerial[3] << 8) | uId;
#endif

		uEthernetFabricMacHigh[uId] = uFabricMacHigh;
		uEthernetFabricMacMid[uId] = uFabricMacMid;
		uEthernetFabricMacLow[uId] = uFabricMacLow;

		xil_printf("Setting MAC for IF %x TO %x %x %x\r\n", uId, uFabricMacHigh, uFabricMacMid, uFabricMacLow);
		SetFabricSourceMACAddress(uId, uEthernetFabricMacHigh[uId], ((uEthernetFabricMacMid[uId] << 16) | (uEthernetFabricMacLow[uId])));
		//SetFabricSourcePortAddress(uId, uEthernetFabricPortAddress[uId]);

		uDHCPTransactionID[uId] = uId;

		uIGMPState[uId] = IGMP_STATE_NOT_JOINED;
		uIGMPSendMessage[uId] = IGMP_SEND_MESSAGE;
		uCurrentIGMPMessage[uId] = 0x0;

		uEthernetNeedsReset[uId] = NEEDS_RESET;

		iSuccess = SoftReset(uId);

#ifdef DEBUG_PRINT
		if (iSuccess == XST_FAILURE)
			xil_printf("ID: %x Failed to do soft reset\r\n", uId);
		else
		    xil_printf("ID: %x Soft reset successful.\r\n", uId);
#endif

	}

	// PERALEX SERIAL NUMBER
	iSuccess = DS2433ReadMem(uRom, 0, uPxSerial, 3, 7, 0, MB_ONE_WIRE_PORT);

	if (iSuccess == XST_FAILURE)
	{
		xil_printf("Failed to read Px serial number.\r\n");
		uPxSerial[0] = 0xFF;
		uPxSerial[1] = 0xFF;
		uPxSerial[2] = 0xFF;
	}

	uPxSerialNumber = uPxSerial[2] + (uPxSerial[1] << 8) + (uPxSerial[0] << 16);
#ifdef DEBUG_PRINT
	xil_printf("Motherboard Px Serial Number: %d\r\n", uPxSerialNumber);
#endif

}

//=================================================================================
//	UpdateGBEPHYConfiguration
//--------------------------------------------------------------------------------
//	This method updates the configuration of the 1GBE PHY to improve the link
//	compatibility with different NICs. The drivers for some NICs do not support sleep 
// 	reliably resulting in occasional packet loss. Also enable flow control through
//	pause frames to prevent possible packet loss in the Marvell 1GBE PHY. This is equivalent 
//	to setting DIS_SLEEP = '1' and ENA_PAUSE = '1'
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void UpdateGBEPHYConfiguration()
{
	int iSuccess;
	u16 uWriteBytes[4];
	u16 uReadBytes[4];
	u16 uCurrentControlReg;

	// Set the switch to the GBE PHY
    uWriteBytes[0] = ONE_GBE_SWITCH_SELECT;
	iSuccess = WriteI2CBytes(MB_I2C_BUS_ID, PCA9546_I2C_DEVICE_ADDRESS, uWriteBytes, 1);

	if (iSuccess == XST_FAILURE)
		xil_printf("UpdateGBEPHYConfiguration: Failed to open I2C switch.\r\n");

	// Select PAGE 0
	uWriteBytes[0]  = 22; // Address of register to write
	uWriteBytes[1]  = 0;
	uWriteBytes[2]  = 0; // PAGE 0

	iSuccess = WriteI2CBytes(MB_I2C_BUS_ID, GBE_88E1111_I2C_DEVICE_ADDRESS, uWriteBytes, 3);

	if (iSuccess == XST_FAILURE)
		xil_printf("UpdateGBEPHYConfiguration: Failed to select PAGE 0.\r\n");

	// Update PHY SPECIFIC CONTROL REGISTER (16), ENERGY DETECT = "00" (DIS_SLEEP = '1')
	uWriteBytes[0] = 16; // Address of register to write
	uWriteBytes[1] = 0xF0;
	uWriteBytes[2] = 0x78;

	iSuccess = WriteI2CBytes(MB_I2C_BUS_ID, GBE_88E1111_I2C_DEVICE_ADDRESS, uWriteBytes, 3);

	if (iSuccess == XST_FAILURE)
		xil_printf("UpdateGBEPHYConfiguration: Failed to update PHY SPECIFIC CONTROL REG.\r\n");

	// Update AUTO NEGOTIATION ADVERTISEMENT REGISTER (4), support PAUSE (ENA_PAUSE = '1')
	uWriteBytes[0] = 4; // Address of register to write
	uWriteBytes[1] = 0x0D;
	uWriteBytes[2] = 0xE1;

	iSuccess = WriteI2CBytes(MB_I2C_BUS_ID, GBE_88E1111_I2C_DEVICE_ADDRESS, uWriteBytes, 3);

	if (iSuccess == XST_FAILURE)
		xil_printf("UpdateGBEPHYConfiguration: Failed to update AUTO NEGOTIATION ADVERTISEMENT REG.\r\n");

	// Read register 0 to get current configuration
	uWriteBytes[0] = 0; // Address of register to read

	iSuccess = WriteI2CBytes(MB_I2C_BUS_ID, GBE_88E1111_I2C_DEVICE_ADDRESS, uWriteBytes, 1);

	if (iSuccess == XST_FAILURE)
		xil_printf("UpdateGBEPHYConfiguration: Failed to update current read register.\r\n");

	iSuccess = ReadI2CBytes(MB_I2C_BUS_ID, GBE_88E1111_I2C_DEVICE_ADDRESS, uReadBytes, 2);

	if (iSuccess == XST_FAILURE)
		xil_printf("UpdateGBEPHYConfiguration: Failed to read CONTROL REG.\r\n");

	uCurrentControlReg = ((uReadBytes[0] << 8) | uReadBytes[1]);
	xil_printf("Current 1GBE PHY configuration: 0x%x.\r\n", uCurrentControlReg);

	// Trigger a soft reset of 1GBE PHY to update configuration
	// Do a soft reset
	uCurrentControlReg = uCurrentControlReg | 0x8000;

	uWriteBytes[0] = 0; // Address of register to write
	uWriteBytes[1] = ((uCurrentControlReg >> 8) & 0xFF);
	uWriteBytes[2] = (uCurrentControlReg & 0xFF);

	iSuccess = WriteI2CBytes(MB_I2C_BUS_ID, GBE_88E1111_I2C_DEVICE_ADDRESS, uWriteBytes, 3);

	if (iSuccess == XST_FAILURE)
		xil_printf("UpdateGBEPHYConfiguration: Failed to write CONTROL REG.\r\n");

	// Close I2C switch
    uWriteBytes[0] = 0x0;
	iSuccess = WriteI2CBytes(MB_I2C_BUS_ID, PCA9546_I2C_DEVICE_ADDRESS, uWriteBytes, 1);

	if (iSuccess == XST_FAILURE)
		xil_printf("UpdateGBEPHYConfiguration: Failed to close I2C switch.\r\n");

}

//=================================================================================
//	InitialiseEthernetInterfaceParameters
//--------------------------------------------------------------------------------
//	This method configures the Ethernet interfaces with some default values.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void InitialiseQSFPMezzanineLocation()
{
	u32 uReg;
	u32 uMezzanineMask;
	u16 uDeviceRom[8];
	u16 uReadBytes[32];
	int iStatus = XST_SUCCESS;
	u16 uOneWirePort;

	uQSFPMezzanineLocation = 0x0;
	uQSFPMezzaninePresent = QSFP_MEZZANINE_NOT_PRESENT;
	uQSFPMezzanineCurrentTxLed = 0x0;
	uQSFPMezzanineCurrentRxLed = 0x0;
	uQSFPUpdateState = QSFP_UPDATING_TX_LEDS;
	uQSFPUpdateStatusEnable = DO_NOT_UPDATE_QSFP_STATUS;
	uQSFPI2CMicroblazeAccess = QSFP_I2C_MICROBLAZE_ENABLE;
	uQSFPStateCounter = 0;
	uQSFPState = QSFP_STATE_RESET;

	uQSFPCtrlReg = QSFP0_RESET | QSFP1_RESET | QSFP2_RESET | QSFP3_RESET;
	WriteBoardRegister(C_WR_ETH_IF_CTL_ADDR, uQSFPCtrlReg);

	uReg = ReadBoardRegister(C_RD_MEZZANINE_STAT_ADDR);

	while ((uQSFPMezzaninePresent == QSFP_MEZZANINE_NOT_PRESENT)&&(uQSFPMezzanineLocation < 0x4))
	{
		uMezzanineMask = 0x1 << uQSFPMezzanineLocation;
		uOneWirePort = uQSFPMezzanineLocation + 0x1;

    debug_printf("[MEZZ %d] ", uQSFPMezzanineLocation);

		// Check if a mezzanine is preset
		if ((uReg & uMezzanineMask) != 0x0)
		{
      debug_printf("PRESENT\r\n");

			// Mezzanine present here, read manufacturer code in 1-wire to see if Peralex board
			iStatus = OneWireReadRom(uDeviceRom, uOneWirePort);

      debug_printf("[MEZZ %d] MFR:", uQSFPMezzanineLocation); /* manufacturer */

			if (iStatus == XST_SUCCESS)
			{
        debug_printf("Peralex\r\n");

        // Mezzanine present here, read manufacturer code in 1-wire to see if Peralex board
				iStatus = DS2433ReadMem(uDeviceRom, 0x0, uReadBytes, 0x1, 0x0, 0x0, uOneWirePort);

        debug_printf("[MEZZ %d] is ", uQSFPMezzanineLocation);
				if ((iStatus == XST_SUCCESS)&&(uReadBytes[0] == 0x50)) // Check if read 'P'
				{
					debug_printf("a QSFP+ MEZZANINE\r\n", uQSFPMezzanineLocation);
					uQSFPMezzaninePresent = QSFP_MEZZANINE_PRESENT;
				}
				else
				{
					debug_printf("not a QSFP+ MEZZANINE...[SKIP]\r\n", uQSFPMezzanineLocation);
					uQSFPMezzanineLocation++;
				}
			}
			else
			{
        debug_printf("unknown...[SKIP]\r\n");
				uQSFPMezzanineLocation++;
			}
		}
		else
		{
      debug_printf("NONE...[SKIP]\r\n");
			uQSFPMezzanineLocation++;
		}

	}

	if (uQSFPMezzaninePresent == QSFP_MEZZANINE_NOT_PRESENT)
		error_printf("Failed to find a QSFP+ MEZZANINE!\r\n");
}

//=================================================================================
//	InitialiseInterruptControllerAndTimer
//--------------------------------------------------------------------------------
//	This method configures the interrupt controller and timer used for DHCP timeouts.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void InitialiseInterruptControllerAndTimer(XTmrCtr * pTimer, XIntc * pInterruptController)
{
	u32 uDHCPTimerOptions;
	int iStatus;

	iStatus = XTmrCtr_Initialize(pTimer, XPAR_TMRCTR_0_DEVICE_ID);

	if (iStatus != XST_SUCCESS)
	   xil_printf("Failed to initialise DHCP retry timer.\r\n");

	iStatus = XIntc_Initialize(pInterruptController, XPAR_INTC_SINGLE_DEVICE_ID);

	if (iStatus == XST_DEVICE_IS_STARTED)
	{
	   XIntc_Stop(pInterruptController);
	   iStatus = XIntc_Initialize(pInterruptController, XPAR_INTC_SINGLE_DEVICE_ID);
	}

	if (iStatus == XST_SUCCESS)
	{
	   iStatus = XIntc_Connect(pInterruptController, XPAR_INTC_0_TMRCTR_0_VEC_ID, (XInterruptHandler) XTmrCtr_InterruptHandler, (void*) pTimer);

	   if (iStatus == XST_SUCCESS)
	   {
		   iStatus =  XIntc_Start(pInterruptController, XIN_REAL_MODE);
		   if (iStatus == XST_SUCCESS)
			   XIntc_Enable(pInterruptController, XPAR_INTC_0_TMRCTR_0_VEC_ID);
		   else
			   xil_printf("Failed to start interrupt controller.\r\n");
	   }
	   else
		   xil_printf("Failed to connect Timer interrupt to interrupt controller.\r\n");
	}
	else
	   xil_printf("Failed to initialise interrupt controller.\r\n");

	microblaze_enable_interrupts();

	XTmrCtr_SetHandler(pTimer, TimerHandler, pTimer);
	uDHCPTimerOptions = XTC_INT_MODE_OPTION | XTC_AUTO_RELOAD_OPTION | XTC_DOWN_COUNT_OPTION;
	XTmrCtr_SetOptions(pTimer, DHCP_RETRY_TIMER_ID, uDHCPTimerOptions);
	XTmrCtr_SetResetValue(pTimer, DHCP_RETRY_TIMER_ID, DHCP_TIMER_RESET_VALUE);
	XTmrCtr_Start(pTimer, DHCP_RETRY_TIMER_ID);

	uIGMPTimerCounter = 0;
	uIGMPTimerCounter = 0;
}

//=================================================================================
//	ReadAndPrintFPGADNA
//--------------------------------------------------------------------------------
//	This method reads and prints out the FPGA DNA value.
//
//	Parameter	Dir		Description
//	---------	---		-----------
//	None
//
//	Return
//	------
//	None
//=================================================================================
void ReadAndPrintFPGADNA()
{
	u32 uDNALow = ReadBoardRegister(C_RD_FPGA_DNA_LOW_ADDR);
	u32 uDNAHigh = ReadBoardRegister(C_RD_FPGA_DNA_HIGH_ADDR);
	u8 uBitShift = 28;
	u8 uNibbleCount;
	u32 uNibble;

	// Print out each nibble in hex format
	xil_printf("FPGA DNA: 0x");

	for (uNibbleCount = 0; uNibbleCount < 8; uNibbleCount++)
	{
		uNibble = (uDNAHigh >> uBitShift) & 0xF;
		xil_printf("%x", uNibble);
		if (uBitShift > 0)
			uBitShift = uBitShift - 4;
	}

	uBitShift = 28;

	for (uNibbleCount = 0; uNibbleCount < 8; uNibbleCount++)
	{
		uNibble = (uDNALow >> uBitShift) & 0xF;
		xil_printf("%x", uNibble);
		if (uBitShift > 0)
			uBitShift = uBitShift - 4;
	}

	xil_printf("\r\n");
}

int main() 
{
	   int iStatus;
	   u32 uReadReg;
#ifdef DEV_PLATFORM
	   u32 uSleepCount;
#endif
	   u8 uEthernetId;
	   u32 uNumWords;
	   u32 uResponsePacketLength;
	   XTmrCtr Timer;
	   XIntc InterruptController;
	   XWdtTb WatchdogTimer;
	   u32 uIGMPGroupAddress;
	   u8 uOKToReboot;
     u16 uDHCPBoundCount[NUM_ETHERNET_INTERFACES] = {0};
     u8 uDHCPBoundTimeout = 0;
#ifdef DO_40GBE_LOOPBACK_TEST
	   u32 uTemp40GBEIPAddress = 0x0A000802;
	   u8 uConfig40GBE[4];
	   uConfig40GBE[0] = 0x1;
	   uConfig40GBE[1] = 0x1;
	   uConfig40GBE[2] = 0x1;
	   uConfig40GBE[3] = 0x1;
#endif

#ifdef DO_1GBE_LOOPBACK_TEST
	   u32 uTemp1GBEIPAddress = 0x0A000702;
	   u8 uConfig1GBE = 0x1;
#endif

     //struct sDHCPObject DHCPContextState[NUM_ETHERNET_INTERFACES];  /* TODO do we have enough stack space???*/
     u8 uTempMac[6];

     /* Temp / Reused variables */
     u32 uSize = 0;       /* used to pass around / hold a packet size */
     u32 uIndex = 0;      /* used to index arrays / buffers */
     u16 *pBuffer = NULL;  /* pointer to working buffer */ 
     u16 uChecksum = 0;
     u32 uTimeout = 0;
     //u32 loop = 0;

     typePacketFilter uPacketType = PACKET_FILTER_UNKNOWN;
     u8 uValidate = 0;

     u32 uKeepAliveReg;

     //u32 *iPtr;
     u32 uMemTest = 0;

#ifdef TIME_PROFILE
     u32 time1 = 0, time2 = 0;
#endif

     /* NOTE: &_text_section_end_ gives us the address of the last program 32bit word
              but we're looking for size in bytes - therefore add 3 to include lower 3 bytes as well
              and add another one to prevent off-by-one error*/
     if (0 == uDoMemoryTest((u8 *) 0x50, (((u32) &_text_section_end_) + 3 - 0x50 + 1), &uMemTest)){
       always_printf("\r\n\r\n[Memory Test] from addr @0x%08x to @0x%08x...\r\n", 0x50, &_text_section_end_);
       always_printf("[Memory Test] expected value {@0x%08x}: 0x%08x\r\n", &_location_checksum_, _location_checksum_);
       always_printf("[Memory Test] computed value              : 0x%08x\r\n", uMemTest);
     } else {
       always_printf("[Memory Test] Error - could not execute\r\n");
     }


#if 0
     /* very crude program memory test */
     for (iPtr = (u32 *)0x50; iPtr <= (u32 *) &_text_section_end_; iPtr++){
       /*print first, middle and last instruction*/
       /*if ((iPtr == (u32 *)0x50) || (iPtr == (u32 *)0x1424c) || (iPtr == (u32 *)0xa150)){
         xil_printf("\r\niPtr @ %p = %08x\r\n", iPtr, *iPtr);
       }*/
        uMemTest = uMemTest + *(iPtr);
     }
     always_printf("\r\n\r\n[Memory Test] from addr @0x%08x to @0x%08x...\r\n", 0x50, &_text_section_end_);
     always_printf("[Memory Test] expected value {@0x%08x}: 0x%08x\r\n", &_location_checksum_, _location_checksum_);
     always_printf("[Memory Test] computed value                  : 0x%08x\r\n", uMemTest);
     /* TODO pass / fail -> what to do upon failure? */
#endif 

	   //Xil_ICacheEnable();
	   //Xil_DCacheEnable();

	   uFrontPanelTimerCounter = 0x0;
	   uFrontPanelLeds = LED_OFF;

	   uDoReboot = NO_REBOOT;

	   InitI2C(0x0, SPEED_100kHz);
	   InitI2C(0x1, SPEED_400kHz);
	   InitI2C(0x2, SPEED_400kHz);
	   InitI2C(0x3, SPEED_400kHz);
	   InitI2C(0x4, SPEED_400kHz);

#ifdef DEV_PLATFORM
	   iStatus = I2CProgramRefClkOsc();
	   if (iStatus == 0)
	   {
		   xil_printf("Programming Refclk OSC success\r\n");
	   }
	   else
	   {
		   xil_printf("Programming Refclk OSC failed\r\n");
	   }
#endif

#if 0
     /* debug code to read MSR register - TODO: remove */
     int k; 

     asm ("mfs %0, rmsr" : "=d" (k));
     xil_printf("MSR 0x%x\r\n", k);
#endif

	   xil_printf("\r\n---Entering main---\r\n");
	   xil_printf("Embedded software version: %d.%d.%d\r\n", EMBEDDED_SOFTWARE_VERSION_MAJOR,
                                                           EMBEDDED_SOFTWARE_VERSION_MINOR,
                                                           EMBEDDED_SOFTWARE_VERSION_PATCH);
	   xil_printf("Running ELF version: %s\r\n", VENDOR_ID);

#ifdef DEV_PLATFORM
	   iStatus = I2CProgramSFPClkOsc();
	   if (iStatus == 0)
	   {
		   xil_printf("Programming SFP OSC success\r\n");
	   }
	   else
	   {
		   xil_printf("Programming SFP OSC failed\r\n");
	   }

	   // Sleep for five seconds because this is a dangerous time for the
	   // system clock
	   for (uSleepCount = 0; uSleepCount < 5000; uSleepCount++)
		   Delay(1000);
#endif


#if 0
	   // Enable the watchdog timer
	   xil_printf("Initialising the WDT.\r\n");

	   iStatus = XWdtTb_Initialize(& WatchdogTimer, XPAR_WDTTB_0_DEVICE_ID);

	   // GT 31/03/2017 FIX DETECTION OF WHETHER PREVIOUS RESET WAS RESULT OF WATCHDOG
	   if (iStatus == XST_DEVICE_IS_STARTED)
	   {
		   if (XWdtTb_IsWdtExpired(& WatchdogTimer))
			   xil_printf("Previous reset result of WDT.\r\n");

		   XWdtTb_Stop(& WatchdogTimer);

		   iStatus = XWdtTb_Initialize(& WatchdogTimer, XPAR_WDTTB_0_DEVICE_ID);

		   XWdtTb_Start(& WatchdogTimer);
	   }
	   else if (iStatus == XST_SUCCESS)
	   {
		   if (XWdtTb_IsWdtExpired(& WatchdogTimer))
			   xil_printf("Previous reset result of WDT.\r\n");

		   XWdtTb_Start(& WatchdogTimer);
	   }
	   else
		   xil_printf("Failed to initialise the WDT.\r\n");
#endif

//#if 0
     XWdtTb_Config *WatchdogTimerConfig;


     /* perhaps move this wdt init to a function to reduce all these nested conditionals -> can return upon failure rather */
     /* Lookup the WDT configuration */
     WatchdogTimerConfig = XWdtTb_LookupConfig(XPAR_WDTTB_0_DEVICE_ID);
     if (WatchdogTimerConfig == NULL){
        always_printf("[WDT] failed to find wdt config\r\n");
     } else {
       always_printf("[WDT] read 1...reg TWCSR0 is 0x%08x\r\n", XWdtTb_ReadReg(WatchdogTimerConfig->BaseAddr, XWT_TWCSR0_OFFSET));
       always_printf("[WDT] read 2...reg TWCSR0 is 0x%08x\r\n", XWdtTb_ReadReg(WatchdogTimerConfig->BaseAddr, XWT_TWCSR0_OFFSET));
       always_printf("[WDT] reg TBR is 0x%08x\r\n", XWdtTb_ReadReg(WatchdogTimerConfig->BaseAddr, XWT_TBR_OFFSET));

       /* Initialize the AXI Timebase Watchdog Timer core */
       iStatus = XWdtTb_CfgInitialize(&WatchdogTimer, WatchdogTimerConfig, WatchdogTimerConfig->BaseAddr);
       if (iStatus == XST_DEVICE_IS_STARTED){
         always_printf("[WDT] failed to initialize the wdt since it is already running\r\n");

         /* check the WRS & WDS bits then restart */
         /* must check this before next stop/re-configure cycle */
         if (XWdtTb_IsWdtExpired(&WatchdogTimer) == TRUE){
           always_printf("[WDT] previous reset was a result of a watchdog timeout!\r\n");
         }

         iStatus = XWdtTb_Stop(&WatchdogTimer);
         if (iStatus == XST_NO_FEATURE){
           always_printf("[WDT] the watchdog timer cannot be stopped, possibly due to 'enable-once' setting\r\n");
         } else if (iStatus == XST_SUCCESS){
           always_printf("[WDT] watchdog stopped\r\n");
           XWdtTb_CfgInitialize(&WatchdogTimer, WatchdogTimerConfig, WatchdogTimerConfig->BaseAddr);
         }

         //XWdtTb_RestartWdt(& WatchdogTimer);
         XWdtTb_Start(&WatchdogTimer);
         always_printf("[WDT] restart watchdog timer!\r\n");
       } else {
         if (XWdtTb_IsWdtExpired(&WatchdogTimer) == TRUE){
           always_printf("[WDT] previous reset was a result of a watchdog timeout!\r\n");
         }
         /* perform a wdt self-test to ensure the timebase is incrementing */
         iStatus = XWdtTb_SelfTest(&WatchdogTimer);
         if (iStatus != XST_SUCCESS){
           always_printf("[WDT] self-test failed\n\r");
         } else {
           /* finally, start the watchdog. The timebase automatically reset*/
           XWdtTb_Start(&WatchdogTimer);
           always_printf("[WDT] starting the watchdog timer...\r\n");
         }
       }
     }

     /* read wdt registers after setup */
     always_printf("[WDT] reg TWCSR0 is 0x%08x\r\n", XWdtTb_ReadReg(WatchdogTimer.Config.BaseAddr, XWT_TWCSR0_OFFSET));
     always_printf("[WDT] reg TBR is 0x%08x\r\n", XWdtTb_ReadReg(WatchdogTimer.Config.BaseAddr, XWT_TBR_OFFSET));
//#endif


     error_printf("[INIT] Interrupts, exceptions and timers ");
     microblaze_register_exception_handler(XIL_EXCEPTION_ID_DIV_BY_ZERO, &DivByZeroException, NULL);
     microblaze_register_exception_handler(XIL_EXCEPTION_ID_M_AXI_I_EXCEPTION, &IBusException, NULL);
     microblaze_register_exception_handler(XIL_EXCEPTION_ID_M_AXI_D_EXCEPTION, &DBusException, NULL);
     microblaze_register_exception_handler(XIL_EXCEPTION_ID_STACK_VIOLATION, &StackViolationException, NULL);
     microblaze_register_exception_handler(XIL_EXCEPTION_ID_ILLEGAL_OPCODE, &IllegalOpcodeException, NULL);
     microblaze_register_exception_handler(XIL_EXCEPTION_ID_UNALIGNED_ACCESS, &UnalignedAccessException, NULL);
	   InitialiseInterruptControllerAndTimer(& Timer, & InterruptController);
     microblaze_enable_exceptions();
     error_printf("[DONE]\r\n");
	   FinishedBootingFromSdram();

	   // GT 7/3/2016 DIS_SLEEP = '1' and ENA_PAUSE = '1'
	   UpdateGBEPHYConfiguration();

	  error_printf("[INIT] Waiting for 1GBE SGMII to come out of reset ");

#define SGMII_1GBE_TIMEOUT 2000000  /* tweaked by experimentation -> about 3 - 4 seconds */
     /* max value determined by watchdog timer */
     /* try to continue before watchdog timer overflows */
     /* TODO: verify any later dependancies linked to this initialization */

     uTimeoutCounter = 20;
	   do
	   {
		   uReadReg = ReadBoardRegister(C_RD_BRD_CTL_STAT_0_ADDR);
	   }while(((uReadReg & 0x1) != 0x1) && (uTimeoutCounter != 0));

     /* if we haven't TIMED OUT then we're OK */
     error_printf("%s", uTimeoutCounter == 0 ? "[TIMED OUT]" : "[OK]");
     error_printf("\r\n"); /* for formatting */

     error_printf("[INIT] Mezzanine locations\r\n");
	   InitialiseQSFPMezzanineLocation();

     error_printf("[INIT] Waiting for HMC to complete init...");
     
     uTimeoutCounter = 20;

	   do
	   {
		   uReadReg = ReadBoardRegister(0x700c0) & ReadBoardRegister(0x7005c) & ReadBoardRegister(0x70058);
	   }while(((uReadReg & 0x1) != 0x1) && (uTimeoutCounter != 0));

     if (uTimeoutCounter == 0){
       error_printf("\r\n[INIT] status: HMC0 = %d | HMC1 = %d | HMC2 = %d\r\n", ReadBoardRegister(0x700c0) & 0x1,
                                                                            ReadBoardRegister(0x7005c) & 0x1,
                                                                            ReadBoardRegister(0x70058) & 0x1);
       error_printf("[INIT] HMC did not init...invoking reconfigure of FPGA\r\n");
       SetOutputMode(SDRAM_READ_MODE, 0x0); // Release flash bus when about to do a reboot
       ResetSdramReadAddress();
       AboutToBootFromSdram();
       Delay(100000);
       IcapeControllerInSystemReconfiguration();
     } else {
       /* if we haven't TIMED OUT then we're OK */
       error_printf("[OK]\r\n");
     }  

     error_printf("[INIT] Interface parameters\r\n");
	   InitialiseEthernetInterfaceParameters();

     /* set bit#1 in C_WR_BRD_CTL_STAT_1_ADDR to 1 to connect 40gbe to user fabric */
     WriteBoardRegister(C_WR_BRD_CTL_STAT_1_ADDR, 0x2);

	   iStatus = XST_SUCCESS;

	   ReadAndPrintFPGADNA();

     /* DHCP State initializations for each interface */
     /* TODO: perhaps create an inline function for the following to neaten up code */
     /* the first 5 octets of the mac address /should/ never change across interfaces */
     uTempMac[0] = (uEthernetFabricMacHigh[0] >> 8) & 0xff;
     uTempMac[1] = (uEthernetFabricMacHigh[0]     ) & 0xff;
     uTempMac[2] = (uEthernetFabricMacMid[0]  >> 8) & 0xff;
     uTempMac[3] = (uEthernetFabricMacMid[0]      ) & 0xff;
     uTempMac[4] = (uEthernetFabricMacLow[0]  >> 8) & 0xff;

     u8 uTempHostNameString[16] = "skarab";   /* 15 chars plus '/0'. To be appended just now with partial mac & i/f. */
     u8 uTempDigit;

     /* stringify mac and append to hostname ("skarab" - see initialization above ) */

     uTempDigit = ((uEthernetFabricMacMid[0] >> 8) & 0xff) / 0x10;  /* upper digit of upper octet of mac-mid */
     uTempHostNameString[6] = uTempDigit > 9 ? ((uTempDigit - 10) + 0x41) : (uTempDigit + 0x30);

     uTempDigit = ((uEthernetFabricMacMid[0] >> 8) & 0xff) % 0x10;  /* lower digit of upper octet of mac-mid */
     uTempHostNameString[7] = uTempDigit > 9 ? ((uTempDigit - 10) + 0x41) : (uTempDigit + 0x30);

     uTempDigit = ((uEthernetFabricMacMid[0]) & 0xff) / 0x10;  /* upper digit of lower octet of mac-mid */
     uTempHostNameString[8] = uTempDigit > 9 ? ((uTempDigit - 10) + 0x41) : (uTempDigit + 0x30);

     uTempDigit = ((uEthernetFabricMacMid[0]) & 0xff) % 0x10;  /* lower digit of lower octet of mac-mid */
     uTempHostNameString[9] = uTempDigit > 9 ? ((uTempDigit - 10) + 0x41) : (uTempDigit + 0x30);

     uTempDigit = ((uEthernetFabricMacLow[0] >> 8) & 0xff) / 0x10;  /* upper digit of upper octet of mac-low */
     uTempHostNameString[10] = uTempDigit > 9 ? ((uTempDigit - 10) + 0x41) : (uTempDigit + 0x30);

     uTempDigit = ((uEthernetFabricMacLow[0] >> 8) & 0xff) % 0x10;  /* lower digit of upper octet of mac-low */
     uTempHostNameString[11] = uTempDigit > 9 ? ((uTempDigit - 10) + 0x41) : (uTempDigit + 0x30);


     uTempHostNameString[12] = '-';

     for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++){
       
       /* 6th octet of mac should equal id anyway */
       uTempMac[5] = uEthernetFabricMacLow[uEthernetId] & 0xff;

       iStatus = uInterfaceInit(&(IFContext[uEthernetId]), (u8 *) &(uReceiveBuffer[uEthernetId][0]), (RX_BUFFER_MAX * 4), (u8 *) uTransmitBuffer, (TX_BUFFER_MAX * 4), uTempMac, uEthernetId);
       if (iStatus != IF_RETURN_OK){
         always_printf("IF   [%02x] Init error!\n\r", uEthernetId);
       }

       /* fill in interface number in host name and terminate string */
       uTempHostNameString[13] = (uEthernetId / 10) + 48;  /* tens digit of interface id*/
       uTempHostNameString[14] = (uEthernetId % 10) + 48;  /* unit digit of interface id*/
       uTempHostNameString[15] = '\0';  /* unit digit of interface id*/

       eventDHCPOnMsgBuilt(&IFContext[uEthernetId], &vSendDHCPMsg, NULL);
       eventDHCPOnLeaseAcqd(&IFContext[uEthernetId], &vSetInterfaceConfig, NULL);
       vDHCPSetHostName(&IFContext[uEthernetId], (char *) &uTempHostNameString);
       /* uDHCPSetStateMachineEnable(&DHCPContextState[uEthernetId], TRUE); */

       //uICMPInit(&ICMPContextState[uEthernetId], (u8 *) &(uReceiveBuffer[uEthernetId][0]), (RX_BUFFER_MAX * 4), (u8 *) uTransmitBuffer, (TX_BUFFER_MAX * 4));


     }

#if 0
     /* debug code to read MSR register - TODO: remove */
     asm ("mfs %0, rmsr" : "=d" (k));
     xil_printf("MSR 0x%x\r\n", k);

     volatile int foo = 8;
     volatile int bar = 0;
     volatile int z;

     z = 8 / 0;
     z++;
     xil_printf("PRINTING z: %d\n\r", z);
#endif

     //WriteBoardRegister(C_WR_FRONT_PANEL_STAT_LED_ADDR, 255);
	   while(1)
	   {
		   if (uQSFPMezzaninePresent == QSFP_MEZZANINE_PRESENT)
			   UpdateQSFPStatus();

		   for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++)
		   {
			   UpdateEthernetLinkUpStatus(&(IFContext[uEthernetId]));

			   if (IFContext[uEthernetId].uIFLinkStatus == LINK_UP)
         {
					uNumWords = GetHostReceiveBufferLevel(uEthernetId);
					if (uNumWords != 0)
					{
            /* zero the receive buffer */
            memset((u8 *) &(uReceiveBuffer[uEthernetId][0]), 0, RX_BUFFER_MAX * 4);

            /* General packet reception handling:
               FILTER ( by layer and packet type)
                  V
               VERIFY (Checksum on relevant layers)
                  V
               VALIDATE (Protocol specifications)
                  V
               PROCESS  (Do the work) */

            // Read packet into receive buffer
            iStatus  = ReadHostPacket(uEthernetId, &(uReceiveBuffer[uEthernetId][0]), uNumWords);
            if (iStatus != XST_SUCCESS){
              error_printf("Read Host Packet Error!\n\r");
            } else {
#ifdef TIME_PROFILE
              time1 = XWdtTb_ReadReg(WatchdogTimerConfig->BaseAddr, XWT_TWCSR0_OFFSET);
#endif
              trace_printf("Read %d words in host packet!\n\r", uNumWords);
              pBuffer = (u16*) &(uReceiveBuffer[uEthernetId][0]);

              /* convert the number of 32bit words to a number of 16bit half-words */
              IFContext[uEthernetId].uNumWordsRead = uNumWords;
              uSize = uNumWords << 1;

              /* correct the endianess */
              for (uIndex = 0; uIndex < uSize; uIndex++){
                pBuffer[uIndex] = Xil_EndianSwap16(pBuffer[uIndex]);
              }

              uPacketType = uRecvPacketFilter(&(IFContext[uEthernetId]));
              trace_printf("PCKT [%02x] Received packet type %d\n\r", uEthernetId, uPacketType);

              /* do relevant checksum validation */
              switch(uPacketType){
                case PACKET_FILTER_DHCP:
                case PACKET_FILTER_CONTROL:
                  /* verify udp checksum */
                  if (uUDPChecksumCalc((u8 *) pBuffer, &uChecksum) == 0){
                    if(uChecksum != 0xffff){
                      error_printf("%s [%02x] RX - Invalid UDP Checksum!\n\r", uPacketType == PACKET_FILTER_DHCP ? "DHCP" : "CTRL", uEthernetId);
                      IFContext[uEthernetId].uRxUdpChecksumErrors++;
                      break;  /*TODO FIXME does this break break the switch or the if statement?*/
                    }
                  }
                  /* else no break statement - fall through */

                case PACKET_FILTER_ICMP:
                  /* ip layer checks */
                  /* FIXME: TODO check ip destination address */
                  /* verify ip header checksum */
                  if(uIPChecksumCalc((u8 *) pBuffer, &uChecksum) == 0){
                    if(uChecksum != 0xffff){
                      error_printf("%s [%02x] RX - Invalid IP Checksum!\n\r", uPacketType == PACKET_FILTER_DHCP ? "DHCP" : uPacketType == PACKET_FILTER_ICMP ? "ICMP" : "CTRL", uEthernetId);
                      IFContext[uEthernetId].uRxIpChecksumErrors++;
                      break;  /*TODO FIXME does this break break the switch or the if statement?*/
                    }
                  }
                  /* else no break statement - fall through */

                case PACKET_FILTER_ARP:
                  uValidate = 1;
                  break;

                case PACKET_FILTER_UNKNOWN:
                case PACKET_FILTER_UNKNOWN_ETH:
                case PACKET_FILTER_UNKNOWN_IP:
                case PACKET_FILTER_UNKNOWN_UDP:
                case PACKET_FILTER_ERROR:
                  warn_printf("PKT FILTER[%02x] %s!\n\r", uEthernetId, uPacketType == PACKET_FILTER_ERROR ? "ERROR" : "UNKNOWN");
                case PACKET_FILTER_DROP:
                default:
                  /* do nothing */
                  uValidate = 0;
                  //uDump = 1;
                  break;
              }

              /* do further protocol specific validation */
              if (uValidate){
                switch(uPacketType){
                  case PACKET_FILTER_DHCP:
                    if (uDHCPMessageValidate(&(IFContext[uEthernetId])) == DHCP_RETURN_OK){
                      debug_printf("DHCP [%02x] valid packet received!\r\n", uEthernetId);
                      uDHCPSetGotMsgFlag(&(IFContext[uEthernetId]));
                      uDHCPStateMachine(&(IFContext[uEthernetId]));   /* run the DHCP state machine immediately */
                    } else {
                      IFContext[uEthernetId].uRxDhcpInvalid++;
                      /* quiet the debug output here a bit since there will be lots of dhcp bcast traffic at startup */
                      /* Note: dhcp server bcast replies will show up as invalid dhcp packets as well */
                      trace_printf("DHCP [%02x] invalid packet received!\r\n", uEthernetId);
                    }
                    break;

                  case PACKET_FILTER_CONTROL:
                    /* the following printf statement should have trace print level in order to prevent performance hit during programming 
                       since printing out to the serial port adds quite a bit of overhead and therefore time */
                    trace_printf("CTRL [%02x] valid packet received!\r\n", uEthernetId);
                    /* TODO: validate - for now, hand over to Peralex code */
                    uFlagRunTask_CTRL[uEthernetId] = 1;
                    break;

                  case PACKET_FILTER_ICMP:
                    if (uICMPMessageValidate(&IFContext[uEthernetId]) == ICMP_RETURN_OK){
                      debug_printf("ICMP [%02x] valid packet received!\r\n", uEthernetId);
                      uFlagRunTask_ICMP_Reply[uEthernetId] = 1;
                    } else {
                      IFContext[uEthernetId].uRxIcmpInvalid++;
                      debug_printf("ICMP [%02x] invalid packet received!\r\n", uEthernetId);
                    }
                    break;

                  case PACKET_FILTER_ARP:
                    iStatus =  uARPMessageValidateReply(&IFContext[uEthernetId]);
                    if (iStatus == ARP_RETURN_REPLY){
                      trace_printf("ARP  [%02x] valid reply received!\r\n", uEthernetId);
                      IFContext[uEthernetId].uRxArpReply++;
                      uFlagRunTask_ARP_Process[uEthernetId] = 1;
                    } else if (iStatus == ARP_RETURN_REQUEST){
                      trace_printf("ARP  [%02x] valid request received!\r\n", uEthernetId);
                      IFContext[uEthernetId].uRxArpRequest++;
                      uFlagRunTask_ARP_Respond[uEthernetId] = 1;
                    } else if (iStatus == ARP_RETURN_CONFLICT){
                      error_printf("ARP  [%02x] network address conflict!\r\n", uEthernetId);
                      IFContext[uEthernetId].uRxArpConflict++;
                      vDHCPStateMachineReset(&(IFContext[uEthernetId]));
                      uDHCPSetStateMachineEnable(&(IFContext[uEthernetId]), SM_TRUE);
                      //uDHCPStateMachine(&DHCPContextState[uEthernetId]);   /* run the DHCP state machine immediately */
                      uFlagRunTask_DHCP = 1;
                    } else if (iStatus == ARP_RETURN_INVALID){
                      debug_printf("ARP  [%02x] malformed packet!\r\n", uEthernetId);
                      IFContext[uEthernetId].uRxArpInvalid++;
                    } else {
                      /* arp packet probably not meant for us */
                      trace_printf("ARP  [%02x] dropping packet!\r\n", uEthernetId);
                    }
                    break;

                  case PACKET_FILTER_UNKNOWN:
                  case PACKET_FILTER_UNKNOWN_ETH:
                  case PACKET_FILTER_UNKNOWN_IP:
                  case PACKET_FILTER_UNKNOWN_UDP:
                    break;

                  case PACKET_FILTER_ERROR:
                    break;

                  default:
                    break;
                }
                uValidate = 0;
              }
            }
          }

          if (uIGMPSendMessage[uEthernetId] == IGMP_SEND_MESSAGE)
          {
            if (uIGMPState[uEthernetId] == IGMP_STATE_JOINED_GROUP)
            {
              // Send IGMP membership reports for each IP in group
              if (uCurrentIGMPMessage[uEthernetId] <= (~uEthernetFabricMultiCastIPAddressMask[uEthernetId]))
              {
                uIGMPGroupAddress = (uEthernetFabricMultiCastIPAddress[uEthernetId] & uEthernetFabricMultiCastIPAddressMask[uEthernetId]) | uCurrentIGMPMessage[uEthernetId];
                CreateIGMPPacket(uEthernetId, (u8*) uTransmitBuffer, & uResponsePacketLength, IGMP_MEMBERSHIP_REPORT, uIGMPGroupAddress);
                uResponsePacketLength = (uResponsePacketLength >> 2);
								iStatus =  TransmitHostPacket(uEthernetId, & uTransmitBuffer[0], uResponsePacketLength);
                if (iStatus != XST_SUCCESS){
                  IFContext[uEthernetId].uTxIpIgmpErr++;
                } else {
                  IFContext[uEthernetId].uTxIpIgmpOk++;
                }
								uCurrentIGMPMessage[uEthernetId]++;
							}
							else
								uIGMPSendMessage[uEthernetId] = IGMP_DONE_SENDING_MESSAGE;

						}
						else if (uIGMPState[uEthernetId] == IGMP_STATE_LEAVING)
						{
							// Send IGMP leave reports for each IP in group
							if (uCurrentIGMPMessage[uEthernetId] <= (~uEthernetFabricMultiCastIPAddressMask[uEthernetId]))
							{
								uIGMPGroupAddress = (uEthernetFabricMultiCastIPAddress[uEthernetId] & uEthernetFabricMultiCastIPAddressMask[uEthernetId]) | uCurrentIGMPMessage[uEthernetId];
								CreateIGMPPacket(uEthernetId, (u8*) uTransmitBuffer, & uResponsePacketLength, IGMP_LEAVE_REPORT, uIGMPGroupAddress);
								uResponsePacketLength = (uResponsePacketLength >> 2);
								iStatus =  TransmitHostPacket(uEthernetId, & uTransmitBuffer[0], uResponsePacketLength);
								uCurrentIGMPMessage[uEthernetId]++;
							}
							else
							{
								// Once finished sending all the LEAVE messages, put into IDLE state
								uIGMPState[uEthernetId] = IGMP_STATE_NOT_JOINED;
								uIGMPSendMessage[uEthernetId] = IGMP_DONE_SENDING_MESSAGE;
							}
						}

          }

         }
       }

      /* simple interrupt driven multi-tasking scheduler */
       /*TODO: FIXME: wrap link up status check around all these tasks - especially the transmit tasks! */

      //----------------------------------------------------------------------------//
      //  DHCP TASK                                                                 //
      //  Triggered on timer interrupt and DHCP message receipt                     //
      //----------------------------------------------------------------------------//
       if (uFlagRunTask_DHCP){
        uFlagRunTask_DHCP = 0;     /* reset task flag */
        for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++){
          uDHCPStateMachine(&(IFContext[uEthernetId]));
        }
      }

      //----------------------------------------------------------------------------//
      //  CONTROL TASK                                                              //
      //  Triggered on CONTROL message receipt                                      //
      //----------------------------------------------------------------------------//
      for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++){
        if (uFlagRunTask_CTRL[uEthernetId]){
          trace_printf("CTRL [%02x] Running control task...\n\r", uEthernetId);
          /* TODO: for now, run Peralex Control Protocol handler, slightly hackish */
          /* flip the endianess again */
          pBuffer = (u16 *) IFContext[uEthernetId].pUserRxBufferPtr;
          // pBuffer = (u16*) &(uReceiveBuffer[uEthernetId][0]);

          /* convert the number of 32bit words to a number of 16bit half-words */
          uSize = IFContext[uEthernetId].uNumWordsRead << 1;

#if 0
          debug_printf("uNumWordsRead = %d\n\r", IFContext[uEthernetId].uNumWordsRead);
          debug_printf("uSize = %d\n\r", uSize);
          /* debug packet dump */
          for (u32 i=0; i<(512 * 2); i++){
            debug_printf("%02x ", IFContext[uEthernetId].pUserRxBufferPtr[i] );
            if ((i != 0) && (i % 15) == 0){
              debug_printf("\n\r");
            }
          }
          debug_printf("\n\r");
#endif

          /* NOTE: the control response needs to be sent quickly since 
             host has timeout in it's state machine (casperfpga),
             therefore reduce over head (printf's, etc.) */

          /* correct the endianess */
          for (uIndex = 0; uIndex < uSize; uIndex++){
            pBuffer[uIndex] = Xil_EndianSwap16(pBuffer[uIndex]);
          }

          iStatus = EthernetRecvHandler(uEthernetId, IFContext[uEthernetId].uNumWordsRead, &uResponsePacketLength);

          if (iStatus == XST_SUCCESS){
            // Send the response packet now
#ifdef TIME_PROFILE
            time2 = XWdtTb_ReadReg(WatchdogTimerConfig->BaseAddr, XWT_TWCSR0_OFFSET);
#endif
            uResponsePacketLength = (uResponsePacketLength >> 2);
            iStatus = TransmitHostPacket(uEthernetId, & uTransmitBuffer[0], uResponsePacketLength);
            if (iStatus != XST_SUCCESS){
              error_printf("CTRL [%02x] Unable to send response\n\r", uEthernetId);
            } else {
              IFContext[uEthernetId].uTxUdpCtrlOk++;
            }
#ifdef TIME_PROFILE
            xil_printf("time2 %08x - time1 %08x = %08x\r\n", time2, time1, time2 - time1);
#endif
          }

          uFlagRunTask_CTRL[uEthernetId] = 0;
        }
      }

      //----------------------------------------------------------------------------//
      //  ICMP TASK                                                                 //
      //  Triggered on ICMP message receipt                                         //
      //----------------------------------------------------------------------------//
      for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++){
        if (uFlagRunTask_ICMP_Reply[uEthernetId]){
          iStatus = uICMPBuildReplyMessage(&IFContext[uEthernetId]);
          if (iStatus != ICMP_RETURN_OK){
            debug_printf("ICMP [%02x] Packet build error!\n\r", uEthernetId);
          } else {
            /* TODO: move this code down one layer of abstraction - similar to DHCP API  */
            uSize = (u32) IFContext[uEthernetId].uMsgSize;    /* bytes */
            pBuffer = (u16 *) IFContext[uEthernetId].pUserTxBufferPtr;
            if (pBuffer != NULL){
              uSize = uSize >> 1;     /* convert number of bytes to number of 16bit half-words */
              for (uIndex = 0; uIndex < uSize; uIndex++){
                pBuffer[uIndex] = Xil_EndianSwap16(pBuffer[uIndex]);
              }
              uSize = uSize >> 1;   /*  now convert quantity to amount of 32-bit words */
              if (TransmitHostPacket(uEthernetId, (u32 *) pBuffer, uSize) != XST_SUCCESS){
                xil_printf("ICMP [%02x] unable to send reply\n\r", 1);
                IFContext[uEthernetId].uTxIpIcmpReplyErr++;
              } else {
                IFContext[uEthernetId].uTxIpIcmpReplyOk++;
              }
            }
          }
          uFlagRunTask_ICMP_Reply[uEthernetId] = 0;
          uFlagRunTask_Diagnostics = 1;   /* dump interface counters to console upon ping */
        }
      }

      //----------------------------------------------------------------------------//
      //  ARP PROCESSING TASK                                                       //
      //  Triggered on ARP reply message reception                                  //
      //----------------------------------------------------------------------------//
      for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++){
        if (uFlagRunTask_ARP_Process[uEthernetId]){

          /* TODO FIXME refactor following lines: remove inline declarations, etc. */
          u32 ip;
          ip = (IFContext[uEthernetId].pUserRxBufferPtr[ARP_FRAME_BASE + ARP_SRC_PROTO_ADDR_OFFSET + 3] & 0xff);

          u32 u = ((IFContext[uEthernetId].pUserRxBufferPtr[ARP_FRAME_BASE + ARP_SRC_HW_ADDR_OFFSET] << 8) & 0xff00) |
            (IFContext[uEthernetId].pUserRxBufferPtr[ARP_FRAME_BASE + ARP_SRC_HW_ADDR_OFFSET + 1] & 0xff); 
          u32 l = ((IFContext[uEthernetId].pUserRxBufferPtr[ARP_FRAME_BASE + ARP_SRC_HW_ADDR_OFFSET + 2] << 24) & 0xff000000) |
            ((IFContext[uEthernetId].pUserRxBufferPtr[ARP_FRAME_BASE + ARP_SRC_HW_ADDR_OFFSET + 3] << 16) & 0xff0000) |
            ((IFContext[uEthernetId].pUserRxBufferPtr[ARP_FRAME_BASE + ARP_SRC_HW_ADDR_OFFSET + 4] << 8) & 0xff00) |
            (IFContext[uEthernetId].pUserRxBufferPtr[ARP_FRAME_BASE + ARP_SRC_HW_ADDR_OFFSET + 5] & 0xff); 

          debug_printf("ARP  [%02x] ENTRY - IP#: %03d MAC: %04x.%04x.%04x\n\r", uEthernetId, ip, (u & 0xffff), ((l >> 16) & 0xffff), (l & 0xffff));
          /* TODO: API functions */
          ProgramARPCacheEntry(uEthernetId, ip, u, l);

          uFlagRunTask_ARP_Process[uEthernetId] = 0;
        }
      }

      //----------------------------------------------------------------------------//
      //  ARP RESPOND TASK                                                          //
      //  Triggered on ARP request message reception                                //
      //----------------------------------------------------------------------------//
      for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++){
        if (uFlagRunTask_ARP_Respond[uEthernetId]){
          iStatus = uARPBuildMessage(&IFContext[uEthernetId], ARP_OPCODE_REPLY, 0);
          if (iStatus != ARP_RETURN_OK){
            error_printf("ARP  [%02x] Packet build error!\n\r", uEthernetId);
          } else {
            /* TODO: move this code down one layer of abstraction - similar to DHCP API  */
            uSize = (u32) IFContext[uEthernetId].uMsgSize;    /* bytes */
            pBuffer = (u16 *) IFContext[uEthernetId].pUserTxBufferPtr;
            if (pBuffer != NULL){
              uSize = uSize >> 1;     /* convert number of bytes to number of 16bit half-words */
              for (uIndex = 0; uIndex < uSize; uIndex++){
                pBuffer[uIndex] = Xil_EndianSwap16(pBuffer[uIndex]);
              }
              uSize = uSize >> 1;   /*  now convert quantity to amount of 32-bit words */
              if (TransmitHostPacket(uEthernetId, (u32 *) pBuffer, uSize) != XST_SUCCESS){
                error_printf("ARP  [%02x] unable to send reply\n\r", 1);
                IFContext[uEthernetId].uTxEthArpErr++;
              } else {
                IFContext[uEthernetId].uTxEthArpReplyOk++;
              }
            }
          }
          uFlagRunTask_ARP_Respond[uEthernetId] = 0;
        }
      }

      //----------------------------------------------------------------------------//
      //  ARP REQUEST TASK                                                          //
      //----------------------------------------------------------------------------//
			if (uUpdateArpRequests == ARP_REQUEST_UPDATE){
			   ArpRequestHandler();
      }

      //----------------------------------------------------------------------------//
      //  LLDP TASK                                                                 //
      //  Triggered on timer interrupt                                              //
      //----------------------------------------------------------------------------//
      if(uFlagRunTask_LLDP){
        for(uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++){
          iStatus = uLLDPBuildPacket(uEthernetId, (u8*) uTransmitBuffer, &uResponsePacketLength);
          if(iStatus == XST_SUCCESS){
            uSize = uResponsePacketLength >> 1; /* 16 bit words */
            pBuffer = (u16 *) uTransmitBuffer;

            for(uIndex = 0; uIndex < uSize; uIndex++){
              pBuffer[uIndex] = Xil_EndianSwap16(pBuffer[uIndex]);
            }
            uSize = uSize >> 1; /* 32 bit words*/
            iStatus = TransmitHostPacket(uEthernetId, (u32*) &pBuffer[0], uSize);
            if (iStatus != XST_SUCCESS){
              IFContext[uEthernetId].uTxEthLldpErr++;
            } else {
              IFContext[uEthernetId].uTxEthLldpOk++;
            }
          }
        }
        uFlagRunTask_LLDP = 0;	
      }

      //----------------------------------------------------------------------------//
      //  CHECK DHCP BOUND TASK                                                     //
      //  Triggered on timer interrupt                                              //
      //----------------------------------------------------------------------------//
      /* keep track of how long we have been "unbound" w.r.t. dhcp - if too long, reset and reload image from sdram */
      if(uFlagRunTask_CheckDHCPBound){
        uFlagRunTask_CheckDHCPBound = 0;
        uDHCPBoundTimeout = 0;
        for(uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++){
          /* TODO: create API function to get state */
          if (IFContext[uEthernetId].DHCPContextState.tDHCPCurrentState < BOUND){
            if (uDHCPBoundCount[uEthernetId] < DHCP_BOUND_COUNTER_VALUE){ /*  prevent overflows */
              uDHCPBoundCount[uEthernetId]++;   /* keep track of how long we've been unbound */
            }
          } else {
            uDHCPBoundCount[uEthernetId] = 0; /* reset the counter if we have progressed passed the BOUND state at any point */
          }
          if (uDHCPBoundCount[uEthernetId] >= DHCP_BOUND_COUNTER_VALUE){
            uDHCPBoundTimeout++;
          }
        }
        /* if we timeout on all the interfaces, line up a reset and reload the image in SDRAM */
        if(uDHCPBoundTimeout >= NUM_ETHERNET_INTERFACES){
          SetOutputMode(SDRAM_READ_MODE, 0x0); // Release flash bus when about to do a reboot
          ResetSdramReadAddress();
          AboutToBootFromSdram();
          uDoReboot = REBOOT_REQUESTED;
          warn_printf("DHCP: RESET - All I/F's timed out!\n\r");
        }
      }

      //----------------------------------------------------------------------------//
      //  DUMP INTERFACE COUNTERS                                                   //
      //  Triggered on ICMP ping and timer                                          //
      //----------------------------------------------------------------------------//
      if (uFlagRunTask_Diagnostics){
        uFlagRunTask_Diagnostics = 0;
        for(uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++){
          IFContext[uEthernetId].uTxTotal = IFContext[uEthernetId].uTxEthArpReplyOk + IFContext[uEthernetId].uTxEthArpRequestOk + IFContext[uEthernetId].uTxEthLldpOk +
                                            IFContext[uEthernetId].uTxIpIcmpReplyOk + IFContext[uEthernetId].uTxIpIgmpOk +
                                            IFContext[uEthernetId].uTxUdpDhcpOk + IFContext[uEthernetId].uTxUdpCtrlOk;

          debug_printf("IF [%d]:  STATUS: %s  IP: %s  Netmask: %s\n\r", uEthernetId,
                                                                        IFContext[uEthernetId].uIFLinkStatus == LINK_UP ? "UP" : "DOWN",
                                                                        IFContext[uEthernetId].stringIFAddrIP,
                                                                        IFContext[uEthernetId].stringIFAddrNetmask);
          debug_printf(" Rx Total:        %10d | Tx Total:     %10d\n\r", IFContext[uEthernetId].uRxTotal            , IFContext[uEthernetId].uTxTotal);
          debug_printf(" Rx  ETH Unknown: %10d | Tx  ARP\n\r",          IFContext[uEthernetId].uRxEthUnknown);
          debug_printf(" Rx  ARP:         %10d | Tx   Reply:   %10d\n\r", IFContext[uEthernetId].uRxEthArp           , IFContext[uEthernetId].uTxEthArpReplyOk);
          debug_printf(" Rx   Reply:      %10d | Tx   Request: %10d\n\r", IFContext[uEthernetId].uRxArpReply         , IFContext[uEthernetId].uTxEthArpRequestOk);
          debug_printf(" Rx   Request:    %10d | Tx   Err:     %10d\n\r", IFContext[uEthernetId].uRxArpRequest       , IFContext[uEthernetId].uTxEthArpErr);
          debug_printf(" Rx   Conflict:   %10d | Tx  LLDP\n\r",          IFContext[uEthernetId].uRxArpConflict);
          debug_printf(" Rx   Invalid:    %10d | Tx   Ok:      %10d\n\r", IFContext[uEthernetId].uRxArpInvalid       , IFContext[uEthernetId].uTxEthLldpOk);
          debug_printf(" Rx  IP:          %10d | Tx   Err:     %10d\n\r", IFContext[uEthernetId].uRxEthIp            , IFContext[uEthernetId].uTxEthLldpErr);
          debug_printf(" Rx   Chksm Err:  %10d | Tx  ICMP\n\r",          IFContext[uEthernetId].uRxIpChecksumErrors);
          debug_printf(" Rx   Unknown:    %10d | Tx   Reply:   %10d\n\r", IFContext[uEthernetId].uRxIpUnknown        , IFContext[uEthernetId].uTxIpIcmpReplyOk);
          debug_printf(" Rx   ICMP:       %10d | Tx   Err:     %10d\n\r", IFContext[uEthernetId].uRxIpIcmp           , IFContext[uEthernetId].uTxIpIcmpReplyErr);
          debug_printf(" Rx    Invalid:   %10d | Tx  IGMP\n\r",          IFContext[uEthernetId].uRxIcmpInvalid);
          debug_printf(" Rx   UDP:        %10d | Tx   Ok:      %10d\n\r", IFContext[uEthernetId].uRxIpUdp            , IFContext[uEthernetId].uTxIpIgmpOk);
          debug_printf(" Rx    Unknown:   %10d | Tx   Err:     %10d\n\r", IFContext[uEthernetId].uRxUdpUnknown       , IFContext[uEthernetId].uTxIpIgmpErr);
          debug_printf(" Rx    CTRL:      %10d | Tx  DHCP\n\r",          IFContext[uEthernetId].uRxUdpCtrl);
          debug_printf(" Rx    DHCP:      %10d | Tx   Ok:      %10d\n\r", IFContext[uEthernetId].uRxUdpDhcp          , IFContext[uEthernetId].uTxUdpDhcpOk);
          debug_printf(" Rx     Invalid:  %10d | Tx   Err:     %10d\n\r", IFContext[uEthernetId].uRxDhcpInvalid      ,  IFContext[uEthernetId].uTxUdpDhcpErr);
          debug_printf("                             | Tx  CTRL\n\r");
          debug_printf("                             | Tx   Ok:      %10d\n\r", IFContext[uEthernetId].uTxUdpCtrlOk);
        }
      }

      if (uDoReboot == REBOOT_REQUESTED)
      {
        // Only do a reboot if all the Ethernet interfaces are no longer part of groups
        uOKToReboot = 1;

        for (uEthernetId = 0; uEthernetId < NUM_ETHERNET_INTERFACES; uEthernetId++)
        {
          if (uIGMPState[uEthernetId] != IGMP_STATE_NOT_JOINED){
            uOKToReboot = 0;
          }
        }
        if (uOKToReboot == 1){
          /* just wait a little while to enable serial port to finish writing out */
          Delay(100000); /* 100ms */
          IcapeControllerInSystemReconfiguration();
        }

      }

      /* to test the watchdog timer - uncomment the following */
      /***************/
      //while(1);
      /***************/

      // Pat the watchdogs

      /* Firmware watchdog */
      /* Read register */
      uKeepAliveReg = ReadBoardRegister(C_RD_UBLAZE_ALIVE_ADDR);

      /* Set the bit in register */
      uKeepAliveReg = uKeepAliveReg | 0x1;

      /* Write back to the register */
      WriteBoardRegister(C_WR_UBLAZE_ALIVE_ADDR, uKeepAliveReg);


      /* Microblaze watchdog */
      XWdtTb_RestartWdt(& WatchdogTimer);
     }

     xil_printf("---Exiting main---\n\r");
     //Xil_DCacheDisable();
     //Xil_ICacheDisable();
     return 0;
}


static int vSendDHCPMsg(struct sIFObject *pIFObjectPtr, void *pUserData){
  u8 uLocalEthernetId;
  u8 uReturnValue;
  u32 uLocalSize;
  u16 *pLocalBuffer = NULL;
  u32 uLocalIndex;
  struct sDHCPObject *pDHCPObjectPtr;

  if (pIFObjectPtr == NULL){
    return -1;
  }

  if (pIFObjectPtr->uIFMagic != IF_MAGIC){
    return -1;
  }

  pDHCPObjectPtr = &(pIFObjectPtr->DHCPContextState);

  if (pDHCPObjectPtr == NULL){
    return -1;
  }

  if (pDHCPObjectPtr->uDHCPMagic != DHCP_MAGIC){
    return -1;
  }
  
  uLocalSize = (u32) pIFObjectPtr->uMsgSize;    /* bytes */
  
  pLocalBuffer = (u16 *) pIFObjectPtr->pUserTxBufferPtr;
  if(pLocalBuffer == NULL){
    return XST_FAILURE;
  }

  uLocalSize = uLocalSize >> 1;     /* 16bit words */

  for (uLocalIndex = 0; uLocalIndex < uLocalSize; uLocalIndex++){
    pLocalBuffer[uLocalIndex] = Xil_EndianSwap16(pLocalBuffer[uLocalIndex]);
  }

  uLocalEthernetId = pIFObjectPtr->uIFEthernetId;

  uLocalSize = uLocalSize >> 1;   /*  32-bit words */
  uReturnValue = TransmitHostPacket(uLocalEthernetId, (u32 *) pLocalBuffer, uLocalSize);
  if (uReturnValue == XST_SUCCESS){
    info_printf("DHCP [%02x] sent DHCP packet with xid 0x%x\n\r", uLocalEthernetId, pDHCPObjectPtr->uDHCPXidCached);
    pIFObjectPtr->uTxUdpDhcpOk++;
  } else {
    error_printf("DHCP [%02x] FAILED to send DHCP packet with xid 0x%x\n\r", uLocalEthernetId, pDHCPObjectPtr->uDHCPXidCached);
    pIFObjectPtr->uTxUdpDhcpErr++;
  }

  return uReturnValue;
}


static int vSetInterfaceConfig(struct sIFObject *pIFObjectPtr, void *pUserData){
  u32 ip = 0;
  u32 netmask = 0;
  u8 id;
  struct sDHCPObject *pDHCPObjectPtr;
  
  if (pIFObjectPtr == NULL){
    return -1;
  }

  if (pIFObjectPtr->uIFMagic != IF_MAGIC){
    return -1;
  }

  pDHCPObjectPtr = &(pIFObjectPtr->DHCPContextState);

  if (pDHCPObjectPtr == NULL){
    return -1;
  }

  if (pDHCPObjectPtr->uDHCPMagic != DHCP_MAGIC){
    return -1;
  }

  id = pIFObjectPtr->uIFEthernetId;
  ip = (pDHCPObjectPtr->arrDHCPAddrYIPCached[0] << 24) |
       (pDHCPObjectPtr->arrDHCPAddrYIPCached[1] << 16) |
       (pDHCPObjectPtr->arrDHCPAddrYIPCached[2] << 8 ) |
        pDHCPObjectPtr->arrDHCPAddrYIPCached[3];

  netmask = (pDHCPObjectPtr->arrDHCPAddrSubnetMask[0] << 24) |
            (pDHCPObjectPtr->arrDHCPAddrSubnetMask[1] << 16) |
            (pDHCPObjectPtr->arrDHCPAddrSubnetMask[2] << 8 ) |
             pDHCPObjectPtr->arrDHCPAddrSubnetMask[3];

  /* convert ip to string and cache for later use / printing */
  if (uIPV4_ntoa((char *) (pIFObjectPtr->stringIFAddrIP), ip) != 0){
    error_printf("DHCP [%02x] Unable to convert IP %x to string.\n\r", id, ip);
  } else {
    pIFObjectPtr->stringIFAddrIP[15] = '\0';
    info_printf("DHCP [%02x] Setting IP address to: %s\r\n", id, pIFObjectPtr->stringIFAddrIP);
  }
#if 0 
  xil_printf("DHCP [%02x] Setting IP address to: %u.%u.%u.%u\r\n", id, ((ip >> 24) & 0xFF),
      ((ip >> 16) & 0xFF),
      ((ip >> 8) & 0xFF),
      (ip & 0xFF));
#endif

  /* convert netmask to string and cache for later use / printing */
  if (uIPV4_ntoa((char *) (pIFObjectPtr->stringIFAddrNetmask), netmask) != 0){
    error_printf("DHCP [%02x] Unable to convert Netmask %x to string.\n\r", id, netmask);
  } else {
    pIFObjectPtr->stringIFAddrNetmask[15] = '\0';
    info_printf("DHCP [%02x] Setting Netmask address to: %s\r\n", id, pIFObjectPtr->stringIFAddrNetmask);
  }

#if 0
  xil_printf("DHCP [%02x] Setting netmask to: %u.%u.%u.%u\r\n", id, ((netmask >> 24) & 0xFF),
      ((netmask >> 16) & 0xFF),
      ((netmask >> 8) & 0xFF),
      (netmask & 0xFF));
#endif

  uEthernetFabricIPAddress[id] = ip;

  /* Cache the ip and netmask in the IF Object layer */
  memcpy(pIFObjectPtr->arrIFAddrIP, pDHCPObjectPtr->arrDHCPAddrYIPCached, 4);
  memcpy(pIFObjectPtr->arrIFAddrNetmask, pDHCPObjectPtr->arrDHCPAddrSubnetMask, 4);

  /* uEthernetSubnet[id] = (ip & 0xFFFFFF00); */
  uEthernetSubnet[id] = (ip & netmask);

  uEthernetGatewayIPAddress[id] = (pDHCPObjectPtr->arrDHCPAddrRoute[0] << 24) |
                                  (pDHCPObjectPtr->arrDHCPAddrRoute[1] << 16) |
                                  (pDHCPObjectPtr->arrDHCPAddrRoute[2] << 8 ) |
                                   pDHCPObjectPtr->arrDHCPAddrRoute[3];

  ProgramARPCacheEntry(id, (ip & 0xFF), uEthernetFabricMacHigh[id], ((uEthernetFabricMacMid[id] << 16) | uEthernetFabricMacLow[id]));

	SetFabricSourceIPAddress(id, ip);

  SetFabricNetmask(id, netmask);

  SetFabricGatewayARPCacheAddress(id, pDHCPObjectPtr->arrDHCPAddrRoute[3]);

  uEnableArpRequests[id] = ARP_REQUESTS_ENABLE;

  /* legacy dhcp states */
  uDHCPState[id] = DHCP_STATE_COMPLETE;

  EnableFabricInterface(id, 1);
  uFlagRunTask_LLDP = 1;
  return 0;
}

/* TODO: act upon these exceptions */
void DivByZeroException(void *Data){
  xil_printf("Divide by zero exception\n\r");
}

void IBusException(void *Data){
  xil_printf("Instruction AXI bus exception\n\r");
}

void DBusException(void *Data){
  xil_printf("Data AXI bus exception\n\r");
}

void StackViolationException(void *Data){
  xil_printf("Stack violation exception\n\r");
}

void IllegalOpcodeException(void *Data){
  xil_printf("Illegal opcode exception\n\r");
}

void UnalignedAccessException(void *Data){
  xil_printf("Unaligned data access exception\n\r");
}
